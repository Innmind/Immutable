{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":"<p>This project brings a set of immutable data structure to bring a uniformity on how to handle data.</p> <p>Before diving in the documentation you may want to read about the philosophy behind the structures design.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>composer require innmind/immutable\n</code></pre>"},{"location":"MONOIDS/","title":"Monoids","text":"<p>Monoids describe a way to combine two values of a given type. A monoid contains an identity value that when combined with another value doesn't change its value. The combine operation has to be associative meaning <code>combine(a, combine(b, c))</code> is the same as <code>combine(combine(a, b), c)</code>.</p> <p>A simple monoid is an addition because adding <code>0</code> (the identity value) to any other integer won't change the value and <code>add(1, add(2, 3))</code> is the the same result as <code>add(add(1, 2), 3)</code> (both return 6).</p> <p>This library comes with a few monoids:</p> <ul> <li><code>Innmind\\Immutable\\Monoid\\Concat</code> to append 2 instances of <code>Innmind\\Immutable\\Str</code> together</li> <li><code>Innmind\\Immutable\\Monoid\\Append</code> to append 2 instances of <code>Innmind\\Immutable\\Sequence</code> together</li> <li><code>Innmind\\Immutable\\Monoid\\MergeSet</code> to append 2 instances of <code>Innmind\\Immutable\\Set</code> together</li> <li><code>Innmind\\Immutable\\Monoid\\MergeMap</code> to append 2 instances of <code>Innmind\\Immutable\\Map</code> together</li> <li><code>Innmind\\Immutable\\Monoid\\ArrayMerge</code> to append 2 arrays together (keys are preserved)</li> </ul>"},{"location":"MONOIDS/#create-your-own","title":"Create your own","text":"<p>To make sure your own monoid follows the laws this library comes with properties you can use (via <code>innmind/black-box</code>) in your test like so:</p> <pre><code>use Innmind\\BlackBox\\Set;\nuse Properties\\Innmind\\Immutable\\Monoid;\n\nreturn static function() {\n    $equals = static fn($a, $b) =&gt; /* this callable is the way to check that 2 values are equal */;\n    // this Set must generate values that are of the type your monoid understands\n    $set = /* an instance of Set */;\n\n    yield properties(\n        'YourMonoid properties',\n        Monoid::properties($set, $equals),\n        Set\\Elements::of(new YourMonoid),\n    );\n\n    foreach (Monoid::list($set, $equals) as $property) {\n        yield proof(\n            'YourMonoid property',\n            given($property),\n            static fn($assert, $property) =&gt; $property-&gt;ensureHeldBy($assert, new YourMonoid),\n        );\n    }\n};\n</code></pre> <p>You can take a look at the proofs for this package monoids to better understand how thiw works.</p>"},{"location":"PHILOSOPHY/","title":"Philosophy","text":"<p>This project was born after working with other programming languages (like Scala) and discovering functional programming. This taught me 2 things:</p> <ul> <li>higher order functions on data structures</li> <li>immutability</li> </ul>"},{"location":"PHILOSOPHY/#higher-order-functions","title":"Higher order functions","text":"<p>PHP comes with a handful of functions to work on arrays and strings but many are missing for common use cases forcing us to implement then again and again.</p> <p>Examples for such cases are a <code>group</code> function on a map/set/sequence or <code>endsWith</code> on a string. <code>group</code> is a specific <code>reduce</code> function where the value computed is a map. <code>endsWith</code> is also a specific <code>substring</code> function.</p> <p>Higher order functions are built on top of smaller, more abstract, ones. Scala, and other languages, provides common ones on their data structures. And this project is heavily inspired from them.</p>"},{"location":"PHILOSOPHY/#immutability","title":"Immutability","text":"<p>One of the core principles of functional programming is that data structures cannot change, you can only create a modified copy of them. This is extremely powerful as you can blindly give your data as a function argument with the certainty that it will not be altered. It allows you only focus on the function you are working one, without the need to worry it will have a side effect in other function, or another function triggering a side effect in yours.</p> <p>Another aspect of immutability is the notion of implicit state. For example in PHP an array is considered immutable because when you give it as a function argument it will create a copy of the variable. But with it comes an implicit state which is its cursor, and it is not reinitialised when a copy is created.</p> <p>This implicit state can generate subtle bugs in your code, that's why the structures in this project don't implement the <code>\\Iterator</code> interface in order to always expose complete functions.</p>"},{"location":"testing/","title":"Testing","text":"<p>This package provides additional sets for <code>innmind/black-box</code> so you can more easily generate: <code>Set</code>s and <code>Sequence</code>s.</p> <p>For the 2 <code>::of()</code> method you can pass as last parameter an instance of <code>Innmind\\BlackBox\\Set\\Intergers</code> to specify the range of elements to generate. By default it's between <code>0</code> and <code>100</code>, depending on the values you generate you may want to lower the upper bound to reduce the memory footprint and speed up your tests.</p>"},{"location":"testing/#set","title":"<code>Set</code>","text":"<pre><code>use Fixtures\\Innmind\\Immutable\\Set;\nuse Innmind\\BlackBox\\Set as BSet;\n\n/** @var BSet&lt;Innmind\\Immutable\\Set&lt;string&gt;&gt; */\n$set = Set::of(\n    BSet\\Strings::any(),\n);\n</code></pre>"},{"location":"testing/#sequence","title":"<code>Sequence</code>","text":"<pre><code>use Fixtures\\Innmind\\Immutable\\Sequence;\nuse Innmind\\BlackBox\\Sequence;\n\n/** @var Set&lt;Innmind\\Immutable\\Sequence&lt;string&gt;&gt; */\n$set = Sequence::of(\n    Sequence\\Strings::any(),\n);\n</code></pre>"},{"location":"structures/","title":"Structures","text":"<p>This library provides the following structures:</p> <ul> <li><code>Sequence</code></li> <li><code>Set</code></li> <li><code>Map</code></li> <li><code>Str</code></li> <li><code>RegExp</code></li> <li><code>Maybe</code></li> <li><code>Either</code></li> <li><code>Attempt</code></li> <li><code>Validation</code></li> <li><code>Identity</code></li> <li><code>State</code></li> <li><code>Fold</code></li> </ul> <p>See the documentation for each structure to understand how to use them.</p> <p>All structures are typed with <code>vimeo/psalm</code>, you must use it in order to verify that you use this library correctly.</p>"},{"location":"structures/attempt/","title":"<code>Attempt</code>","text":"<p>This structures is similar to <code>Either</code> but where the left value is necessarily an instance of <code>\\Throwable</code>.</p> <p>Its main use is as a return type of any function that would normally throw an exception. Instead of throwing and let the exception bubble up the call stack, it's caught in the structure and forces you to deal with this exception at some point.</p> <p>Unlike an <code>Either</code> the error type can't be more precise than <code>\\Throwable</code>.</p> <p><code>Attempt</code> is intended to be used as a return type where the call may fail but you can't know in advance all the possible failing scenarii. This is the case for interfaces where the kind of error will depend on the implementation details.</p> <p>If you already know all the possible failing scenarii you should use an <code>Either</code> instead.</p> Note <p>In other languages this monad is called <code>Try</code>. But this is a reserved keyword in PHP, hence the name <code>Attempt</code>.</p>"},{"location":"structures/attempt/#error","title":"<code>::error()</code>","text":"<p>This builds an <code>Attempt</code> that failed with the given exception:</p> <pre><code>$attempt = Attempt::error(new \\Exception);\n</code></pre> <p>You will rarely use this method directly.</p>"},{"location":"structures/attempt/#result","title":"<code>::result()</code>","text":"<p>This builds an <code>Attempt</code> that succeeded with the given value:</p> <pre><code>$attempt = Attempt::result($anyValue);\n</code></pre> <p>You will rarely use this method directly.</p>"},{"location":"structures/attempt/#of","title":"<code>::of()</code>","text":"<p>This builds an <code>Attempt</code> that will immediately call the callable and catch any exception:</p> <pre><code>$attempt = Attempt::of(static function() {\n    if (/* some condition */) {\n        throw new \\Exception;\n    }\n\n    return $anyValue;\n});\n</code></pre> <p>This is the equivalent of:</p> <pre><code>$doStuff = static function() {\n    if (/* some condition */) {\n        return Attempt::error(new \\Exception);\n    }\n\n    return Attempt::result($anyValue);\n};\n$attempt = $doStuff();\n</code></pre> <p>This is very useful to wrap any third party code to a monadic style.</p>"},{"location":"structures/attempt/#defer","title":"<code>::defer()</code>","text":"<p>This builds an <code>Attempt</code> where the callable passed will be called only when <code>-&gt;memoize()</code> or <code>-&gt;match()</code> is called.</p> <pre><code>$attempt = Attempt::defer(static fn() =&gt; Attempt::of(doStuff(...)));\n// doStuff has not been called yet\n$attempt-&gt;memoize();\n// doStuff has been called\n</code></pre> <p>The main use case is for IO operations.</p>"},{"location":"structures/attempt/#-map","title":"<code>-&gt;map()</code>","text":"<p>This will apply the map transformation on the result if no previous error occured.</p> ResultError <pre><code>$attempt = Attempt::of(static fn() =&gt; 1/2)\n    -&gt;map(static fn(int $i) =&gt; $i*2);\n</code></pre> <p>Here <code>$attempt</code> contains <code>1</code>;</p> <pre><code>$attempt = Attempt::of(static fn() =&gt; 1/0)\n    -&gt;map(static fn(int $i) =&gt; $i*2);\n</code></pre> <p>Here <code>$attempt</code> contains a <code>DivisionByZeroError</code> and the callable passed to <code>map</code> has not been called.</p>"},{"location":"structures/attempt/#-flatmap","title":"<code>-&gt;flatMap()</code>","text":"<p>This is similar to <code>-&gt;map()</code> except the callable passed to it must return an <code>Attempt</code> indicating that it may fail.</p> <pre><code>$attempt = Attempt::result(2 - $reduction)\n    -&gt;flatMap(static fn(int $divisor) =&gt; Attempt::of(\n        static fn() =&gt; 42 / $divisor,\n    ));\n</code></pre> <p>If <code>$reduction</code> is <code>2</code> then <code>$attempt</code> will contain a <code>DivisionByZeroError</code> otherwise for any other value it will contain a fraction of <code>42</code>.</p>"},{"location":"structures/attempt/#-guard","title":"<code>-&gt;guard()</code>","text":"<p>This behaves like <code>-&gt;flatMap()</code> except any error contained in the attempt returned by the callable won't be recovered when calling <code>-&gt;xrecover()</code>.</p>"},{"location":"structures/attempt/#-match","title":"<code>-&gt;match()</code>","text":"<p>This extracts the result value but also forces you to deal with any potential error.</p> <pre><code>$result = Attempt::of(static fn() =&gt; 2 / $reduction)-&gt;match(\n    static fn($fraction) =&gt; $fraction,\n    static fn(\\Throwable $e) =&gt; $e,\n);\n</code></pre> <p>If <code>$reduction</code> is <code>0</code> then <code>$result</code> will be an instance of <code>DivisionByZeroError</code>, otherwise it will be a fraction of <code>2</code>.</p>"},{"location":"structures/attempt/#-maperror","title":"<code>-&gt;mapError()</code>","text":"<p>This will allow you to change the error or wrap the previous one.</p> <pre><code>$attempt = Attempt::of(static fn() =&gt; 1/0)\n    -&gt;mapError(static fn(\\Throwable $e) =&gt; new \\Exception('something bad happened', 0, $e));\n</code></pre> <p>Here <code>$attempt</code> contains an <code>\\Exception</code> because the first <code>Attempt</code> raised a <code>DivisionByZeroError</code>.</p>"},{"location":"structures/attempt/#-recover","title":"<code>-&gt;recover()</code>","text":"<p>This will allow you to recover in case of a previous error.</p> <pre><code>$attempt = Attempt::of(static fn() =&gt; 1/0)\n    -&gt;recover(static fn(\\Throwable $e) =&gt; Attempt::result(42));\n</code></pre> <p>Here <code>$attempt</code> is <code>42</code> because the first <code>Attempt</code> raised a <code>DivisionByZeroError</code>.</p>"},{"location":"structures/attempt/#-xrecover","title":"<code>-&gt;xrecover()</code>","text":"<p>This behaves like <code>-&gt;recover()</code> except when conjointly used with <code>-&gt;guard()</code>. Guarded errors can't be recovered.</p> <p>An example of this problem is an HTTP router with 2 routes. One tries to handle a <code>POST</code> request, then do some logging, the other tries to handle a <code>GET</code> request. It would look something like this:</p> <pre><code>$response = handlePost($request)\n    -&gt;flatMap(static fn($response) =&gt; log($response))\n    -&gt;recover(static fn() =&gt; handleGet($request));\n</code></pre> <p>The problem here is that if the request is indeed a <code>POST</code> we handle it then log the response. But if the logging fails then we try to handle it as a <code>GET</code> request. In this case we handle the request twice, which isn't good.</p> <p>The correct approach is:</p> <pre><code>$response = handlePost($request)\n    -&gt;guard(static fn($response) =&gt; log($response))\n    -&gt;xrecover(static fn() =&gt; handleGet($request));\n</code></pre> <p>This way if the logging fails it will return this failure and not call <code>handleGet()</code>.</p>"},{"location":"structures/attempt/#-maybe","title":"<code>-&gt;maybe()</code>","text":"<p>This converts an <code>Attempt</code> to a <code>Maybe</code>.</p> ResultError <pre><code>Attempt::result($value)-&gt;maybe();\n// is the same as\nMaybe::just($value);\n</code></pre> <pre><code>Attempt::error(new \\Exception)-&gt;maybe()\n// is the same as\nMaybe::nothing();\n</code></pre>"},{"location":"structures/attempt/#-either","title":"<code>-&gt;either()</code>","text":"<p>This converts an <code>Attempt</code> to a <code>Either</code>.</p> ResultError <pre><code>Attempt::result($value)-&gt;either();\n// is the same as\nEither::right($value);\n</code></pre> <pre><code>Attempt::error(new \\Exception)-&gt;either()\n// is the same as\nEither::left(new \\Exception);\n</code></pre>"},{"location":"structures/attempt/#-memoize","title":"<code>-&gt;memoize()</code>","text":"<p>This method force to load the contained value into memory. This is only useful for a deferred <code>Attempt</code>, this will do nothing for other attempts as the value is already known.</p> <pre><code>Attempt::defer(static fn() =&gt; Attempt::result(\\rand()))\n    -&gt;map(static fn($i) =&gt; $i * 2) // value still not loaded here\n    -&gt;memoize() // call the rand function and then apply the map and store it in memory\n    -&gt;match(\n        static fn($i) =&gt; doStuff($i),\n        static fn() =&gt; null,\n    );\n</code></pre>"},{"location":"structures/attempt/#-unwrap","title":"<code>-&gt;unwrap()</code>","text":"<p>This will return the result or throw any previous error.</p> <pre><code>$result = Attempt::of(static fn() =&gt; 1 / $divisor)\n    -&gt;unwrap();\n</code></pre> <p>Here <code>$result</code> is necessarily a fraction of <code>1</code> but this code may raise the <code>DivisionByZeroError</code> exception.</p>"},{"location":"structures/attempt/#-eitherway","title":"<code>-&gt;eitherWay()</code>","text":"<p>This method kind of combines both <code>flatMap</code> and <code>recover</code> in a single call. This is useful when you can't call <code>recover</code> after <code>flatMap</code> because you don't want to override the error returned by <code>flatMap</code>.</p> <pre><code>/**\n * @return Attempt&lt;SideEffect&gt; SideEffect when on macOS\n */\nfunction isMac(): Attempt { /* ... */}\n/**\n * @return Attempt&lt;SideEffect&gt;\n */\nfunction runMac(): Attempt { /* ... */ }\n/**\n * @return Attempt&lt;SideEffect&gt;\n */\nfunction runLinux(): Attempt { /* ... */ }\n\n$_ = isMac()-&gt;eitherWay(runMac(...), runLinux(...));\n</code></pre> <p>In this case we want to run <code>runLinux</code> only when <code>isMac</code> returns an error which is possible thanks to <code>-&gt;eitherWay()</code>. Contrary to <code>isMac()-&gt;flatMap(runMac(...))-&gt;recover(runLinux(...))</code> that could lead to <code>runLinux</code> to be called if <code>runMac</code> returns an error.</p>"},{"location":"structures/either/","title":"<code>Either</code>","text":"<p>This structure represent an alternative between 2 possibles types <code>L</code> and <code>R</code> (left and right), with a bias toward the right value. Usually this is used to represent <code>Either&lt;SomeError, ValidValue&gt;</code>, the valid value being on the right side benefit the right bias as <code>map</code>, <code>flatMap</code> and <code>filter</code> are done on the right value.</p> <p>This technique is borrowed from the functional programming world.</p> <p>For the examples below we will use the given imaginary functions:</p> <pre><code>use Innmind\\Immutable\\Either;\n\n/**\n * @return Either&lt;Error, User&gt;\n */\nfunction identify(ServerRequest $request): Either {\n    if (/* some condition */) {\n        return Either::right($theUser);\n    }\n\n    return Either::left(new Error('User not found'));\n}\n\n/**\n * @return Either&lt;Error, Resource&gt;\n */\nfunction accessResource(User $user): Either {\n    if (/* check if user is allowed */) {\n        return Either::right($resource);\n    }\n\n    return Either::left(new Error('User is not allowed'));\n}\n</code></pre> <p><code>ServerRequest</code>, <code>User</code>, <code>Resource</code> and <code>Error</code> are imaginary classes.</p>"},{"location":"structures/either/#left","title":"<code>::left()</code>","text":"<p>This builds an <code>Either</code> instance with the given value in the left hand side.</p> <pre><code>$either = Either::left($anyValue);\n</code></pre> <p>Usually this side is used for errors.</p>"},{"location":"structures/either/#right","title":"<code>::right()</code>","text":"<p>This builds an <code>Either</code> instance with the given value in the right hand side.</p> <pre><code>$either = Either::right($anyValue);\n</code></pre> <p>Usually this side is used for valid values.</p>"},{"location":"structures/either/#defer","title":"<code>::defer()</code>","text":"<p>This is used to return an <code>Either</code> early with known data type but with the value that will be extracted from the callable when calling <code>-&gt;match()</code>. The main use case is for IO operations.</p> <pre><code>$either = Either::defer(static function() {\n    try {\n        $value = /* wait for some IO operation like an http call */;\n\n        return Either::right($value);\n    } catch (\\Throwable $e) {\n        return Either::left($e);\n    }\n});\n</code></pre> <p>Methods called (except <code>match</code>) on a deferred <code>Either</code> will not be called immediately but will be composed to be executed once you call <code>match</code>.</p> <p>This means that if you never call <code>match</code> on a deferred <code>Either</code> it will do nothing.</p>"},{"location":"structures/either/#-map","title":"<code>-&gt;map()</code>","text":"<p>This will apply the map transformation on the right value if there is one, otherwise it's only a type change.</p> <pre><code>/** @var Either&lt;Error, User&gt; */\n$either = identify($serverRequest);\n/** @var Either&lt;Error, Impersonated&gt; */\n$impersonated = $either-&gt;map(\n    fn(User $user): Impersonated =&gt; $user-&gt;impersonateAdmin(),\n);\n</code></pre>"},{"location":"structures/either/#-flatmap","title":"<code>-&gt;flatMap()</code>","text":"<p>This is similar to <code>-&gt;map()</code> but instead of returning the new right value you return a new <code>Either</code> object.</p> <pre><code>/** @var Either&lt;Error, User&gt; */\n$either = identify($serverRequest);\n/** @var Either&lt;Error, Resource&gt; */\n$resource = $either-&gt;flatMap(fn(User $user): Either =&gt; accessResource($user));\n</code></pre>"},{"location":"structures/either/#-match","title":"<code>-&gt;match()</code>","text":"<p>This is the only way to extract the wrapped value.</p> <pre><code>/** @var Response */\n$response = identify($serverRequest)\n    -&gt;flatMap(fn(User $user): Either =&gt; accessResource($user))\n    -&gt;match(\n        fn(Resource $resource) =&gt; new Response(200, $resource-&gt;toString()),\n        fn(Error $error) =&gt; new Response(400, $error-&gt;message()), //(1)\n    );\n</code></pre> <ol> <li>Here the error can be from <code>identify</code> or from <code>accessResource</code>.</li> </ol> <p><code>Response</code> is an imaginary class.</p>"},{"location":"structures/either/#-otherwise","title":"<code>-&gt;otherwise()</code>","text":"<p>This is like <code>-&gt;flatMap()</code> but is called when the instance contains a left value. The callable must return a new <code>Either</code> object.</p> <pre><code>/**\n * @return Either&lt;Error, User&gt;\n */\nfunction identifyViaJsonPayload(ServerRequest $request): Either {\n    if (/* find user from json payload */) {\n        return Either::right($theUser);\n    }\n\n    return Either::left(new Error('User not found'));\n}\n\n/** @var Either&lt;Error, User&gt; */\n$either = identify($request)\n    -&gt;otherwise(fn() =&gt; identifyViaJsonPayload($request));\n</code></pre>"},{"location":"structures/either/#-filter","title":"<code>-&gt;filter()</code>","text":"<p>Use this method to validate the right value when there is one. If the predicate doesn't accept the right value then it will return the value from the second callable as a left value.</p> <pre><code>identify($request)\n    -&gt;filter(\n        fn(User $user): bool =&gt; $user-&gt;isAllowed(),\n        fn() =&gt; new Error('User is not allowed'),\n    )\n    -&gt;match(\n        fn(User $user) =&gt; doSomething($user), //(1)\n        fn(Error $error) =&gt; print($error-&gt;message()), //(2)\n    );\n</code></pre> <ol> <li>Here we know the user is allowed.</li> <li>Can be \"User not found\" or \"User is not allowed\".</li> </ol>"},{"location":"structures/either/#-leftmap","title":"<code>-&gt;leftMap()</code>","text":"<p>This is similar to the <code>-&gt;map()</code> function but will be applied on the left value only.</p> <pre><code>/** @var Either&lt;ErrorResponse, User&gt; */\n$either = identify($request)\n    -&gt;leftMap(fn(Error $error) =&gt; new ErrorResponse($error));\n</code></pre>"},{"location":"structures/either/#-maybe","title":"<code>-&gt;maybe()</code>","text":"<p>This returns a <code>Maybe</code> containing the right value, in case of a left value it returns a <code>Maybe</code> with nothing inside.</p> <pre><code>Either::right('something')-&gt;maybe()-&gt;match(\n    static fn($value) =&gt; $value,\n    static fn() =&gt; null,\n); // returns 'something'\nEither::left('something')-&gt;maybe()-&gt;match(\n    static fn($value) =&gt; $value,\n    static fn() =&gt; null,\n); // returns null\n</code></pre>"},{"location":"structures/either/#-attempt","title":"<code>-&gt;attempt()</code>","text":"<p>This returns an <code>Attempt</code> containing the right value, in case of a left value it returns an <code>Attempt</code> with the error provided by the callable inside.</p> <pre><code>Either::right('something')\n    -&gt;attempt(static fn() =&gt; new \\Exception)\n    -&gt;unwrap(); // returns 'something'\nEither::left('something')\n    -&gt;attempt(static fn(string $left) =&gt; new \\Exception($left))\n    -&gt;unwrap(); // throws new \\Exception('something')\n</code></pre>"},{"location":"structures/either/#-memoize","title":"<code>-&gt;memoize()</code>","text":"<p>This method force to load the contained value into memory. This is only useful for a deferred <code>Either</code>, this will do nothing for other either as the value is already known.</p> <pre><code>Either::defer(function() {\n    return Either::right(\\rand());\n})\n    -&gt;map(static fn($i) =&gt; $i * 2) // value still not loaded here\n    -&gt;memoize() // call the rand function and then apply the map and store it in memory\n    -&gt;match(\n        static fn($i) =&gt; doStuff($i),\n        static fn() =&gt; null,\n    );\n</code></pre>"},{"location":"structures/either/#-flip","title":"<code>-&gt;flip()</code>","text":"<p>This method changes the side of the value contained in the <code>Either</code>. This is useful when you want to only keep the error and discard the right value you would use like this:</p> <pre><code>/**\n * @return Either&lt;SomeError, SomeData&gt;\n */\nfunction foo() { /*...*/}\n\n$error = foo() // returns type Either&lt;SomeError, SomeData&gt;\n    -&gt;flip() // returns type Either&lt;SomeData, SomeError&gt;\n    -&gt;maybe(); // returns type Maybe&lt;SomeError&gt;\n</code></pre>"},{"location":"structures/either/#-eitherway","title":"<code>-&gt;eitherWay()</code>","text":"<p>This method is kind of combines both <code>flatMap</code> and <code>otherwise</code> in a single call. This is useful when you can't call <code>otherwise</code> after <code>flatMap</code> because you don't want to override the left value returned by <code>flatMap</code>.</p> <pre><code>/**\n * @return Either&lt;SomeError, SideEffect&gt; SideEffect when on macOS\n */\nfunction isMac(): Either { /* ... */}\n/**\n * @return Either&lt;SomeError, SideEffect&gt;\n */\nfunction runMac(): Either { /* ... */ }\n/**\n * @return Either&lt;SomeError, SideEffect&gt;\n */\nfunction runLinux(): Either { /* ... */ }\n\n$_ = isMac()-&gt;eitherWay(runMac(...), runLinux(...));\n</code></pre> <p>In this case we want to run <code>runLinux</code> only when <code>isMac</code> returns a <code>SideEffect</code> which is possible thanks to <code>-&gt;eitherWay()</code>. Contrary to <code>isMac()-&gt;flatMap(runMac(...))-&gt;otherwise(runLinux(...))</code> that could lead to <code>runLinux</code> to be called if <code>runMac</code> returns an error.</p>"},{"location":"structures/fold/","title":"<code>Fold</code>","text":"Deprecated <p><code>Fold</code> is deprecated and will be removed in the next major release.</p> <p>The <code>Fold</code> monad is intented to work with (infinite) stream of data by folding each element to a single value. This monad distinguishes between the type used to fold and the result type, this allows to inform the stream that it's no longer necessary to extract elements as the folding is done.</p> <p>An example is reading from a socket as it's an infinite stream of strings:</p> <pre><code>$socket = \\stream_socket_client(/* args */);\n/** @var Fold&lt;string, list&lt;string&gt;, list&lt;string&gt;&gt; */\n$fold = Fold::with([]);\n\ndo {\n    // production code should wait for the socket to be \"ready\"\n    $line = \\fgets($socket);\n\n    if ($line === false) {\n        $fold = Fold::fail('socket not readable');\n    }\n\n    $fold = $fold\n        -&gt;map(static fn($lines) =&gt; \\array_merge($lines, [$line]))\n        -&gt;flatMap(static fn($lines) =&gt; match (\\end($lines)) {\n            \"quit\\n\" =&gt; Fold::result($lines),\n            default =&gt; Fold::with($lines),\n        });\n    $continue = $fold-&gt;match(\n        static fn() =&gt; true, // still folding\n        static fn() =&gt; false, // got a result so stop\n        static fn() =&gt; false, // got a failure so stop\n    );\n} while ($continue);\n\n$fold-&gt;match(\n    static fn() =&gt; null, // unreachable in this case because no more folding outside the loop\n    static fn($lines) =&gt; \\var_dump($lines),\n    static fn($failure) =&gt; throw new \\RuntimeException($failure),\n);\n</code></pre> <p>This example will read all lines from the socket until one line contains <code>quit\\n</code> then the loop will stop and either dump all the lines to the output or <code>throw new RuntimeException('socket not reachable')</code>.</p>"},{"location":"structures/fold/#with","title":"<code>::with()</code>","text":"<p>This named constructor accepts a value with the notion that more elements are necessary to compute a result</p>"},{"location":"structures/fold/#result","title":"<code>::result()</code>","text":"<p>This named constructor accepts a result value meaning that folding is finished.</p>"},{"location":"structures/fold/#fail","title":"<code>::fail()</code>","text":"<p>This named constructor accepts a failure value meaning that the folding operation failed and no result will be reachable.</p>"},{"location":"structures/fold/#-map","title":"<code>-&gt;map()</code>","text":"<p>This method allows to transform the value being folded.</p> <pre><code>$fold = Fold::with([])-&gt;map(static fn(array $folding) =&gt; new \\ArrayObject($folding));\n</code></pre>"},{"location":"structures/fold/#-flatmap","title":"<code>-&gt;flatMap()</code>","text":"<p>This method allows to both change the value and the state, for example switching from folding to result.</p> <pre><code>$someElement = /* some data */;\n$fold = Fold::with([])-&gt;flatMap(static fn($elements) =&gt; match ($someElement) {\n    'finish' =&gt; Fold::result($elements),\n    default =&gt; Fold::with(\\array_merge($elements, [$someElement])),\n});\n</code></pre>"},{"location":"structures/fold/#-mapresult","title":"<code>-&gt;mapResult()</code>","text":"<p>Same as <code>-&gt;map()</code> except that it will transform the result value when there is one.</p>"},{"location":"structures/fold/#-mapfailure","title":"<code>-&gt;mapFailure()</code>","text":"<p>Same as <code>-&gt;map()</code> except that it will transform the failure value when there is one.</p>"},{"location":"structures/fold/#-maybe","title":"<code>-&gt;maybe()</code>","text":"<p>This will return the terminal value of the folding, meaning either a result or a failure.</p> <pre><code>Fold::with([])-&gt;maybe()-&gt;match(\n    static fn() =&gt; null, // not called as still folding\n    static fn() =&gt; doStuff(), // called as it is still folding\n);\nFold::result([])-&gt;maybe()-&gt;match(\n    static fn($either) =&gt; $either-&gt;match(\n        static fn($result) =&gt; $result, // the value here is the array passed to ::result() above\n        static fn() =&gt; null, // not called as it doesn't contain a failure\n    ),\n    static fn() =&gt; null, // not called as we have a result\n);\nFold::fail('some error')-&gt;maybe()-&gt;match(\n    static fn($either) =&gt; $either-&gt;match(\n        static fn() =&gt; null, // not called as we have a failure\n        static fn($error) =&gt; var_dump($error), // the value here is the string passed to ::fail() above\n    ),\n    static fn() =&gt; null, // not called as we have a result\n);\n</code></pre>"},{"location":"structures/fold/#-match","title":"<code>-&gt;match()</code>","text":"<p>This method allows to extract the value contained in the object.</p> <pre><code>Fold::with([])-&gt;match(\n    static fn($folding) =&gt; doStuf($folding), // value from ::with()\n    static fn() =&gt; null, // not called\n    static fn() =&gt; null, // not called\n);\nFold::result([])-&gt;match(\n    static fn() =&gt; null, // not called\n    static fn($result) =&gt; doStuf($result), // value from ::result()\n    static fn() =&gt; null, // not called\n);\nFold::fail('some error')-&gt;match(\n    static fn() =&gt; null, // not called\n    static fn() =&gt; null, // not called\n    static fn($error) =&gt; doStuf($error), // value from ::fail()\n);\n</code></pre>"},{"location":"structures/identity/","title":"<code>Identity</code>","text":"<p>This is the simplest monad there is. It's a simple wrapper around a value to allow chaining calls on this value.</p> <p>Let's say you have a string you want to camelize, here's how you'd do it:</p> IdentityImperativePyramid of doom <pre><code>$value = Identity::of('some value to camelize')\n    -&gt;map(fn($string) =&gt; \\explode(' ', $string))\n    -&gt;map(fn($parts) =&gt; \\array_map(\n        \\ucfirst(...),\n        $parts,\n    ))\n    -&gt;map(fn($parts) =&gt; \\implode('', $parts))\n    -&gt;map(\\lcfirst(...))\n    -&gt;unwrap();\n\necho $value; // outputs \"someValueToCamelize\"\n</code></pre> <pre><code>$string = 'some value to camelize';\n$parts = \\explode(' ', $string);\n$parts = \\array_map(\n    \\ucfirst(...),\n    $parts,\n);\n$string = \\implode('', $parts);\n$value = \\lcfirst($string);\n\necho $value; // outputs \"someValueToCamelize\"\n</code></pre> <pre><code>$value = \\lcfirst(\n    \\implode(\n        '',\n        \\array_map(\n            \\ucfirst(...),\n            \\explode(\n                ' ',\n                'some value to camelize',\n            ),\n        ),\n    ),\n);\n\necho $value; // outputs \"someValueToCamelize\"\n</code></pre> <p>In the end this monad does not provide any behaviour, it's a different way to write and read your code.</p>"},{"location":"structures/identity/#lazy-computation","title":"Lazy computation","text":"<p>By default the <code>Identity</code> apply each transformation when <code>map</code> or <code>flatMap</code> is called. But you can defer the application of the transformations to when the <code>unwrap</code> method is called. This can be useful when you're not sure the computed value will be really used.</p> <p>Instead of using <code>Identity::of()</code> you'd do:</p> <pre><code>$value = Identity::defer(static fn() =&gt; 'some value'); //(1)\n// or\n$value = Identity::lazy(static fn() =&gt; 'some value');\n// then you can use the identity as before (see above)\n</code></pre> <ol> <li>Here the value is a string but you can use whatever type you want.</li> </ol> <p>The difference between <code>lazy</code> and <code>defer</code> is that the first one will recompute the underlying value each time the <code>unwrap</code> method is called while the other one will compute it once and then always return the same value.</p>"},{"location":"structures/identity/#wrapping-the-underlying-value-in-a-sequence","title":"Wrapping the underlying value in a <code>Sequence</code>","text":"<p>This monad has a <code>toSequence</code> method that will create a new <code>Sequence</code> containing the underlying value.</p> <p>Both examples do the same:</p> DeclarativeImperative <pre><code>$value = Identity::of('some value')\n    -&gt;toSequence();\n</code></pre> <pre><code>$value = Sequence::of('some value');\n</code></pre> <p>On the surface this seems to not be very useful, but it becomes interesting when the identity is lazy or deferred. The laziness is propagated to the sequence.</p> <p>Both examples do the same:</p> DeclarativeImperative <pre><code>$value = Identity::lazy(static fn() =&gt; 'some value')\n    -&gt;toSequence();\n</code></pre> <pre><code>$value = Sequence::lazy(static fn() =&gt; yield 'some value');\n</code></pre> <p>This combined to the <code>Sequence::toIdentity()</code> allows you to chain and compose sequences without having to be aware if the source sequence is lazy or not.</p>"},{"location":"structures/map/","title":"<code>Map</code>","text":"<p>A map is an unordered list of pair of elements, think of it like an associative array or an <code>array&lt;T, S&gt;</code> in the Psalm nomenclature. But with the added benefit that the keys can be of any type, even objects!</p>"},{"location":"structures/map/#named-constructors","title":"Named constructors","text":""},{"location":"structures/map/#of","title":"<code>::of()</code>","text":"<pre><code>use Innmind\\Immutable\\Map;\n\n/** @var Map&lt;object, int&gt; */\n$map = Map::of();\n</code></pre> <p>The first type is for the keys and the second one for the values. This order is the same for all the methods below.</p>"},{"location":"structures/map/#add-values","title":"Add values","text":""},{"location":"structures/map/#-__invoke","title":"<code>-&gt;__invoke()</code>","text":"<p>Augment the map with a new pair of elements. If the key already exist it will replace the value.</p> <pre><code>$map = Map::of();\n$map = ($map)(1, 2);\n$map-&gt;equals(\n    Map::of([1, 2]),\n);\n</code></pre>"},{"location":"structures/map/#-put","title":"<code>-&gt;put()</code>","text":"<p>This is an alias for <code>-&gt;__invoke()</code>.</p>"},{"location":"structures/map/#-merge","title":"<code>-&gt;merge()</code>","text":"<p>Create a new map with all pairs from both maps. Pairs from the map in the argument will replace existing pairs from the original map.</p> <pre><code>$a = Map::of([1, 2], [3, 4]);\n$b = Map::of([5, 6], [3, 7]);\n$a-&gt;merge($b)-&gt;equals(\n    Map::of(\n        [1, 2],\n        [5, 6],\n        [3, 7],\n    ),\n); // true\n</code></pre>"},{"location":"structures/map/#access-values","title":"Access values","text":""},{"location":"structures/map/#-size","title":"<code>-&gt;size()</code>","text":"<p>This returns the number of elements in the map.</p> <pre><code>$map = Map::of([1, 2]);\n$map-&gt;size(); // 1\n</code></pre>"},{"location":"structures/map/#-count","title":"<code>-&gt;count()</code>","text":"<p>This is an alias for <code>-&gt;size()</code>, but you can also use the PHP function <code>\\count</code> if you prefer.</p> <pre><code>$map = Map::of([1, 2]);\n$map-&gt;size(); // 1\n\\count($map); // 1\n</code></pre>"},{"location":"structures/map/#-get","title":"<code>-&gt;get()</code>","text":"<p>Return an instance of <code>Maybe</code> that may contain the value associated to the given key (if it exists).</p> <pre><code>$map = Map::of([1, 2], [3, 4]);\n$map-&gt;get(1); // Maybe::just(2)\n$map-&gt;get(2); // Maybe::nothing()\n</code></pre>"},{"location":"structures/map/#-contains","title":"<code>-&gt;contains()</code>","text":"<p>Check if the map contains a given key.</p> <pre><code>$map = Map::of([1, 2], [3, 4]);\n$map-&gt;contains(1); // true\n$map-&gt;contains(2); // false\n</code></pre>"},{"location":"structures/map/#-keys","title":"<code>-&gt;keys()</code>","text":"<p>Return a <code>Set</code> of all the keys of the map.</p> <pre><code>$keys = Map::of([24, 1], [42, 2])-&gt;keys();\n$keys-&gt;equals(Set::of(24, 42)); // true\n</code></pre>"},{"location":"structures/map/#-values","title":"<code>-&gt;values()</code>","text":"<p>Return a <code>Sequence</code> of all the values of the map.</p> <pre><code>$values = Map::of([24, 1], [42, 2])-&gt;values();\n$values-&gt;equals(Sequence::of(1, 2)); // true\n</code></pre> <p>It returns a <code>Sequence</code> because it can contain duplicates, the order is not guaranteed as a map is not ordered.</p>"},{"location":"structures/map/#-find","title":"<code>-&gt;find()</code>","text":"<p>This will return the first pair that matches the given predicate (remember that the map is not ordered).</p> <pre><code>use Innmind\\Immutable\\Pair;\n\nMap::of([1, 2], [3, 4], [5, 6], [7, 8])-&gt;find(\n    fn($key, $value) =&gt; ($key + $value) &gt; 10,\n); // Maybe::just(new Pair(5, 6))\n</code></pre>"},{"location":"structures/map/#-matches","title":"<code>-&gt;matches()</code>","text":"<p>Check if all the pairs of the map matches the given predicate.</p> <pre><code>$isOdd = fn($i) =&gt; $i % 2 === 1;\nMap::of([1, 2], [3, 4])-&gt;matches(fn($key) =&gt; $isOdd($key)); // true\nMap::of([1, 2], [3, 4])-&gt;matches(fn($key, $value) =&gt; $isOdd($value)); // false\n</code></pre>"},{"location":"structures/map/#-any","title":"<code>-&gt;any()</code>","text":"<p>Check if at least one pair of the map matches the given predicate.</p> <pre><code>$isOdd = fn($i) =&gt; $i % 2 === 1;\nMap::of([1, 2], [3, 4])-&gt;any(fn($key) =&gt; $isOdd($key)); // true\nMap::of([1, 3], [3, 4])-&gt;any(fn($key, $value) =&gt; $isOdd($value)); // true\nMap::of([1, 2], [3, 4])-&gt;any(fn($key, $value) =&gt; $isOdd($value)); // false\n</code></pre>"},{"location":"structures/map/#-empty","title":"<code>-&gt;empty()</code>","text":"<p>Tells whether there is at least one pair or not.</p> <pre><code>Map::of()-&gt;empty(); // true\nMap::of([1, 2])-&gt;empty(); // false\n</code></pre>"},{"location":"structures/map/#transform-values","title":"Transform values","text":""},{"location":"structures/map/#-map","title":"<code>-&gt;map()</code>","text":"<p>Create a new map of the same type with the exact same number of pairs but modified by the given function.</p> <pre><code>$urls = Map::of(\n    ['example.com', 1],\n    ['github.com', 1],\n    ['news.ycombinator.com', 1],\n    ['reddit.com', 1],\n);\n$incremented = $map-&gt;map(fn($key, $value) =&gt; $value + 1);\n$incremented-&gt;equals(\n    Map::of(\n        ['example.com', 2]\n        ['github.com', 2]\n        ['news.ycombinator.com', 2]\n        ['reddit.com', 2]\n    ),\n);\n</code></pre>"},{"location":"structures/map/#-flatmap","title":"<code>-&gt;flatMap()</code>","text":"<p>This is similar to <code>-&gt;map()</code> but instead of returning a new value it returns a new <code>Map</code> for each value, all maps are merged to form only one <code>Map</code>.</p> <p>This is usefull to generate multiple pairs for each initial pair or to modify the keys.</p> <pre><code>$urls = Map::of(\n    ['example.com', 1],\n    ['github.com', 1],\n    ['news.ycombinator.com', 1],\n    ['reddit.com', 1],\n);\n$withScheme = $map-&gt;map(fn($key, $value) =&gt; Map::of(\n    [\"http://$key\", $value],\n    [\"https://$key\", $value],\n));\n$withScheme-&gt;equals(\n    Map::of(\n        ['http://example.com', 1],\n        ['https://example.com', 1],\n        ['http://github.com', 1],\n        ['https://github.com', 1],\n        ['http://news.ycombinator.com', 1],\n        ['https://news.ycombinator.com', 1],\n        ['http://reddit.com', 1],\n        ['https://reddit.com', 1],\n    ),\n);\n</code></pre>"},{"location":"structures/map/#filter-values","title":"Filter values","text":""},{"location":"structures/map/#-filter","title":"<code>-&gt;filter()</code>","text":"<p>Removes the pairs from the map that don't match the given predicate.</p> <pre><code>$map = Map::of([1, 1], [3, 2]);\n$map = $map-&gt;filter(fn($key, $value) =&gt; ($key + $value) % 2 === 0);\n$map-&gt;equals(Map::of([1, 1]));\n</code></pre>"},{"location":"structures/map/#-exclude","title":"<code>-&gt;exclude()</code>","text":"<p>Removes the pairs from the map that match the given predicate.</p> <pre><code>$map = Map::of([1, 1], [3, 2]);\n$map = $map-&gt;exclude(fn($key, $value) =&gt; ($key + $value) % 2 === 0);\n$map-&gt;equals(Map::of([3, 2]));\n</code></pre>"},{"location":"structures/map/#-remove","title":"<code>-&gt;remove()</code>","text":"<p>Remove the pair from the map with the given key.</p> <pre><code>$map = Map::of([2, 3], [3, 4]);\n$map-&gt;remove(3)-&gt;equals(Map::of([2, 3])); // true\n</code></pre>"},{"location":"structures/map/#extract-values","title":"Extract values","text":""},{"location":"structures/map/#-reduce","title":"<code>-&gt;reduce()</code>","text":"<p>Iteratively compute a value for all the pairs in the map.</p> <pre><code>$map = Map::of([1, 2], [2, 3], [3, 3]);\n$sum = $map-&gt;reduce(0, fn($sum, $key, $value) =&gt; $sum + $key + $value);\n$sum; // 14\n</code></pre>"},{"location":"structures/map/#misc","title":"Misc.","text":""},{"location":"structures/map/#-equals","title":"<code>-&gt;equals()</code>","text":"<p>Check if two maps are identical.</p> <pre><code>$a = Map::of([1, 2], [3, 4]);\n$b = Map::of([3, 4], [1, 2]);\n$a-&gt;equals($b); // true\n$a-&gt;equals(Map::of(); // false\n</code></pre>"},{"location":"structures/map/#-foreach","title":"<code>-&gt;foreach()</code>","text":"<p>Use this method to call a function for each pair of the map. Since this structure is immutable it returns a <code>SideEffect</code> object, as its name suggest it is the only place acceptable to create side effects.</p> <pre><code>$sideEffect = Map::of(['hello', 'world'])-&gt;foreach(\n    function(string $key, string $value): void {\n        echo \"$key $value\"; // will print \"hello world\"\n    },\n);\n</code></pre> <p>In itself the <code>SideEffect</code> object has no use except to avoid psalm complaining that the <code>foreach</code> method is not used.</p>"},{"location":"structures/map/#-groupby","title":"<code>-&gt;groupBy()</code>","text":"<p>This will create multiples maps with elements regrouped under the same key computed by the given function.</p> <pre><code>$urls = Map::of(\n    ['http://example.com', 1],\n    ['http://example.com/foo', 1],\n    ['https://example.com', 2],\n    ['ftp://example.com', 4],\n);\n/** @var Innmind\\Immutable\\Map&lt;string, Sequence&lt;string&gt;&gt; */\n$map = $urls-&gt;groupBy(fn(string $url, int $whatever): string =&gt; \\parse_url($url)['scheme']);\n$map\n    -&gt;get('http')\n    -&gt;match(\n        static fn($group) =&gt; $group,\n        static fn() =&gt; Map::of(),\n    )\n    -&gt;equals(Map::of(\n        ['http://example.com', 1],\n        ['http://example.com/foo', 1]\n    )); // true\n$map\n    -&gt;get('https')\n    -&gt;match(\n        static fn($group) =&gt; $group,\n        static fn() =&gt; Map::of(),\n    )\n    -&gt;equals(Map::of(['https://example.com', 2])); // true\n$map\n    -&gt;get('ftp')\n    -&gt;match(\n        static fn($group) =&gt; $group,\n        static fn() =&gt; Map::of(),\n    )\n    -&gt;equals(Map::of(['ftp://example.com', 4])); // true\n</code></pre>"},{"location":"structures/map/#-partition","title":"<code>-&gt;partition()</code>","text":"<p>This method is similar to <code>-&gt;groupBy()</code> method but the map keys are always booleans. The difference is that here the 2 keys are always present whereas with <code>-&gt;groupBy()</code> it will depend on the original map.</p> <pre><code>$map = Map::of([1, 2], [2, 3], [3, 3]);\n/** @var Map&lt;bool, Map&lt;int, int&gt;&gt; */\n$map = $map-&gt;partition(fn($key, $value) =&gt; ($key + $value) % 2 === 0);\n$map\n    -&gt;get(true)\n    -&gt;match(\n        static fn($partition) =&gt; $partition,\n        static fn() =&gt; Map::of(),\n    )\n    -&gt;equals(Map::of([3, 3])); // true\n$map\n    -&gt;get(false)\n    -&gt;match(\n        static fn($partition) =&gt; $partition,\n        static fn() =&gt; Map::of(),\n    )\n    -&gt;equals(Map::of([1, 2], [2, 3])); // true\n</code></pre>"},{"location":"structures/map/#-clear","title":"<code>-&gt;clear()</code>","text":"<p>Return an empty new map of the same type. Useful to avoid to respecify the templates types of the map in a new docblock annotation.</p> <pre><code>$map = Map::of([1, 2], [3, 4]);\n$map-&gt;clear()-&gt;size(); // 0\n</code></pre>"},{"location":"structures/map/#-tosequence","title":"<code>-&gt;toSequence()</code>","text":"<p>Returns an unsorted <code>Sequence</code> with all value pairs.</p> <pre><code>$map = Map::of([1, 2], [3, 4]);\n$map\n    -&gt;toSequence()\n    -&gt;equals(Sequence::of(\n        new Pair(1, 2),\n        new Pair(3, 4),\n    )); // true\n</code></pre>"},{"location":"structures/maybe/","title":"<code>Maybe</code>","text":"<p>This type is another approach to represent the possible abscence of a value. Instead of a function returning a result of type <code>T</code> or <code>null</code> it would return <code>Maybe&lt;T&gt;</code>.</p> <p>This technique is borrowed from the functional programming world.</p> <p>For the examples below will use the given imaginary function:</p> <pre><code>use Innmind\\Immutable\\Maybe;\n\n/** @return Maybe&lt;string&gt; */\nfunction env(string $name): Maybe {\n    $value = \\getenv($name);\n\n    return $value === false ? Maybe::nothing() : Maybe::just($value);\n}\n</code></pre>"},{"location":"structures/maybe/#just","title":"<code>::just()</code>","text":"<p>This named constructor tells that there is a value that can be used.</p>"},{"location":"structures/maybe/#nothing","title":"<code>::nothing()</code>","text":"<p>This named constructor tells that there is no value that can be used.</p>"},{"location":"structures/maybe/#of","title":"<code>::of()</code>","text":"<p>This is a shortcut so you don't have to write the <code>if (is_null)</code> yourself.</p> <pre><code>$maybe = \\is_null($value) ? Maybe::nothing() : Maybe::just($value);\n// is equivalent to\n$maybe = Maybe::of($value);\n</code></pre>"},{"location":"structures/maybe/#all","title":"<code>::all()</code>","text":"<p>This is a shortcut to make sure all the wrappers contain a value to easily combine them. If any of the arguments doesn't contain a value then the call to <code>-&gt;map()</code> or <code>-&gt;flatMap()</code> will return a <code>Maybe::nothing()</code>.</p> <pre><code>$kernel = Maybe::all(env('ENV'), env('DEBUG'))\n    -&gt;map(static fn(string $env, string $debug) =&gt; new Kernel($env, $debug))\n    -&gt;match(\n        static fn(Kernel $kernel) =&gt; $kernel,\n        static fn() =&gt; throw new \\Exception('ENV or DEBUG environment variable is missing (or both)'),\n    );\n</code></pre>"},{"location":"structures/maybe/#defer","title":"<code>::defer()</code>","text":"<p>This is used to return a <code>Maybe</code> early with known data type but with the value that will be extracted from the callable when calling <code>-&gt;match()</code>. The main use case is for IO operations.</p> <pre><code>$maybe = Maybe::defer(static function() {\n    $value = /* wait for some IO operation like an http call */;\n\n    return Maybe::of($value);\n});\n</code></pre> <p>Methods called (except <code>match</code>) on a deferred <code>Maybe</code> will not be called immediately but will be composed to be executed once you call <code>match</code>.</p> <p>This means that if you never call <code>match</code> on a deferred <code>Maybe</code> it will do nothing.</p>"},{"location":"structures/maybe/#-map","title":"<code>-&gt;map()</code>","text":"<p>This function allows you to transform the value into another value that will be wrapped in a <code>Maybe</code> object.</p> <pre><code>$dsn = env('LOGGER_DSN');\n/** @var Maybe&lt;array&gt; */\n$parsedDsn = $dsn-&gt;map(fn(string $dsn): array =&gt; \\parse_url($dsn));\n</code></pre>"},{"location":"structures/maybe/#-flatmap","title":"<code>-&gt;flatMap()</code>","text":"<p>This is similar to the <code>-&gt;map()</code> function but instead of returning the value you need to return a wrapped value.</p> <pre><code>/**\n * This is an imaginary function that would retrieve a User from a database\n * (or elsewhere)\n *\n * @param string $id\n *\n * @return Maybe&lt;User&gt;\n */\nfunction getUser(string $id): Maybe {\n    // imaginary implementation\n}\n\n$adminId = env('ADMIN_ID');\n/** @var Maybe&lt;User&gt; */\n$admin = $adminId-&gt;flatMap(fn($id) =&gt; getUser($id));\n</code></pre> <p>This allows you to continue chaining calls on <code>Maybe</code> instances by juggling with wrapped types.</p>"},{"location":"structures/maybe/#-match","title":"<code>-&gt;match()</code>","text":"<p>This is the only way to extract the wrapped value. But you need to handle both cases where the value exists or where the value doesn't exist.</p> <p>The example below uses the imaginary <code>Logger</code> and <code>NullLogger</code> classes.</p> <pre><code>$dsn = env('LOGGER_DSN');\n$logger = $dsn-&gt;match(\n    static fn(string $url) =&gt; new Logger($url),\n    static fn() =&gt; new NullLogger,\n);\n</code></pre>"},{"location":"structures/maybe/#-otherwise","title":"<code>-&gt;otherwise()</code>","text":"<p>This is like <code>-&gt;flatMap()</code> but is called when there is no value wrapped.</p> <p>This is useful to create a chain of alternative strategies.</p> <pre><code>/** @var Maybe&lt;string&gt; */\n$dsn = env('DATABASE_LOGGER_DSN')\n    -&gt;otherwise(fn() =&gt; env('SENTRY_LOGGER_DSN'))\n    -&gt;otherwise(fn() =&gt; env('FILE_LOGGER_DSN'));\n</code></pre> <p>This example will first try to retrieve the <code>DATABASE_LOGGER_DSN</code>, if it doesn't exist it will try the <code>SENTRY_LOGGER_DSN</code>. If the sentry one exists then it will not try to retrieve <code>FILE_LOGGER_DSN</code>.</p>"},{"location":"structures/maybe/#-filter","title":"<code>-&gt;filter()</code>","text":"<p>When there is a wrapped value it will call the given predicate. If the condition is successful then nothing happens but if it fails it will return a <code>Maybe::nothing()</code>.</p> <pre><code>$dsn = env('LOGGER_DSN');\n/** @var Maybe&lt;string&gt; */\n$validDsn = $dsn-&gt;filter(fn(string $url): bool =&gt; \\filter_var($url, \\FILTER_VALIDATE_URL));\n</code></pre> <p><code>$validDsn</code> will contain either a valid url or nothing.</p>"},{"location":"structures/maybe/#-keep","title":"<code>-&gt;keep()</code>","text":"<p>This is similar to <code>-&gt;filter()</code> with the advantage of psalm understanding the type in the new <code>Maybe</code>.</p>"},{"location":"structures/maybe/#-exclude","title":"<code>-&gt;exclude()</code>","text":"<p>This is the inverse of the <code>-&gt;filter()</code> method.</p>"},{"location":"structures/maybe/#-either","title":"<code>-&gt;either()</code>","text":"<p>This returns an <code>Either</code> containing the value on the right side and <code>null</code> on the left side.</p> <pre><code>Maybe::just('something')-&gt;either()-&gt;match(\n    static fn($right) =&gt; $right,\n    static fn() =&gt; null,\n); // returns 'something'\nMaybe::nothing()\n    -&gt;either()\n    -&gt;leftMap(static fn() =&gt; 'something')\n    -&gt;match(\n        static fn() =&gt; null,\n        static fn($left) =&gt; $left,\n    ); // return 'something'\n</code></pre>"},{"location":"structures/maybe/#-attempt","title":"<code>-&gt;attempt()</code>","text":"<p>This returns an <code>Attempt</code> containing the value as a result and the error is provided by the callable.</p> <pre><code>Maybe::just('something')\n    -&gt;attempt(static fn() =&gt; new \\Exception)\n    -&gt;unwrap(); // returns 'something'\nMaybe::nothing()\n    -&gt;attempt(static fn() =&gt; new \\Exception)\n    -&gt;unwrap(); // throws the exception\n</code></pre>"},{"location":"structures/maybe/#-memoize","title":"<code>-&gt;memoize()</code>","text":"<p>This method force to load the contained value into memory. This is only useful for a deferred <code>Maybe</code>, this will do nothing for other maybe as the value is already known.</p> <pre><code>Maybe::defer(function() {\n    return Maybe::just(\\rand());\n})\n    -&gt;map(static fn($i) =&gt; $i * 2) // value still not loaded here\n    -&gt;memoize() // call the rand function and then apply the map and store it in memory\n    -&gt;match(\n        static fn($i) =&gt; doStuff($i),\n        static fn() =&gt; null,\n    );\n</code></pre>"},{"location":"structures/maybe/#-tosequence","title":"<code>-&gt;toSequence()</code>","text":"<p>This method will return a <code>Sequence</code> with one or no value. This can be useful when \"<code>flatMap</code>ping\" a <code>Sequence</code> like this:</p> <pre><code>$vars = Sequence::of('DB_URL', 'MAILER_URL', /* and so on */)\n    -&gt;flatMap(static fn($var) =&gt; env($var)-&gt;toSequence());\n</code></pre> <p>This example uses the <code>env</code> function defined at the start of this documentation.</p> <p>This is equivalent to:</p> <pre><code>$vars = Sequence::of('DB_URL', 'MAILER_URL', /* and so on */)\n    -&gt;flatMap(static fn($var) =&gt; env($var)-&gt;match(\n        static fn($value) =&gt; Sequence::of($value),\n        static fn() =&gt; Sequence::of(),\n    ));\n</code></pre>"},{"location":"structures/maybe/#-eitherway","title":"<code>-&gt;eitherWay()</code>","text":"<p>This method is kind of combines both <code>flatMap</code> and <code>otherwise</code> in a single call. This is useful when you can't call <code>otherwise</code> after <code>flatMap</code> because you don't want to override the nothingness returned by <code>flatMap</code>.</p> <pre><code>/**\n * @return Maybe&lt;SideEffect&gt; SideEffect when on macOS\n */\nfunction isMac(): Maybe { /* ... */}\n/**\n * @return Maybe&lt;SideEffect&gt;\n */\nfunction runMac(): Maybe { /* ... */ }\n/**\n * @return Maybe&lt;SideEffect&gt;\n */\nfunction runLinux(): Maybe { /* ... */ }\n\n$_ = isMac()-&gt;eitherWay(runMac(...), runLinux(...));\n</code></pre> <p>In this case we want to run <code>runLinux</code> only when <code>isMac</code> returns nothing which is possible thanks to <code>-&gt;eitherWay()</code>. Contrary to <code>isMac()-&gt;flatMap(runMac(...))-&gt;otherwise(runLinux(...))</code> that could lead to <code>runLinux</code> to be called if <code>runMac</code> returns nothing.</p>"},{"location":"structures/regexp/","title":"<code>RegExp</code>","text":"<p>This class is here to help make sure that a string is a regular expression so you can safely type against this class.</p>"},{"location":"structures/regexp/#of","title":"<code>::of()</code>","text":"<p>This is the named cosntructor for this class.</p> <pre><code>RegExp::of('/foo/') instanceof RegExp; // true\nRegExp::of('foo'); // throws Innmind\\Immutable\\Exception\\LogicException\n</code></pre>"},{"location":"structures/regexp/#-matches","title":"<code>-&gt;matches()</code>","text":"<p>Both examples do the same thing.</p> <pre><code>RegExp::of('/^a/')-&gt;matches(Str::of('abcdef'));\nStr::of('abcdef')-&gt;matches('/^a/');\n</code></pre>"},{"location":"structures/regexp/#-capture","title":"<code>-&gt;capture()</code>","text":"<p>Both examples do the same thing.</p> <pre><code>RegExp::of('@^(?:http://)?(?P&lt;host&gt;[^/]+)@i')-&gt;capture(Str::of('http://www.php.net/index.html'));\nStr::of('http://www.php.net/index.html')-&gt;capture('@^(?:http://)?(?P&lt;host&gt;[^/]+)@i');\n</code></pre>"},{"location":"structures/regexp/#-tostring","title":"<code>-&gt;toString()</code>","text":"<p>Return the string representation of the regular expression.</p> <pre><code>RegExp::of('/foo/')-&gt;toString(); // '/foo/'\n</code></pre>"},{"location":"structures/sequence/","title":"<code>Sequence</code>","text":"<p>A sequence is an ordered list of elements, think of it like an array such as <code>[1, 'a', new stdClass]</code> or a <code>list&lt;T&gt;</code> in the Psalm nomenclature.</p> <p>Methods with the  symbol indicates that they will trigger loading the generator for deferred and lazy sequences.</p>"},{"location":"structures/sequence/#named-constructors","title":"Named constructors","text":""},{"location":"structures/sequence/#of","title":"<code>::of()</code>","text":"<p>The <code>of</code> static method allows you to create a new sequence with all the elements passed as arguments.</p> <pre><code>use Innmind\\Immutable\\Sequence;\n\n/** @var Sequence&lt;int&gt; */\nSequence::of(1, 2, 3, $etc);\n</code></pre>"},{"location":"structures/sequence/#defer","title":"<code>::defer()</code>","text":"<p>This named constructor is for advanced use cases where you want the data of your sequence to be loaded upon use only and not initialisation.</p> <p>An example for such a use case is a sequence of log lines coming from a file:</p> <pre><code>$sequence = Sequence::defer((function() {\n    yield from readSomeFile('apache.log');\n})());\n</code></pre> <p>The method ask a generator that will provide the elements. Once the elements are loaded they are kept in memory so you can run multiple operations on it without loading the file twice.</p> <p>Beware of the case where the source you read the elements is not altered before the first use of the sequence.</p>"},{"location":"structures/sequence/#lazy","title":"<code>::lazy()</code>","text":"<p>This is similar to <code>::defer()</code> with the exception that the elements are not kept in memory but reloaded upon each use.</p> <pre><code>$sequence = Sequence::lazy(function() {\n    yield from readSomeFile('apache.log');\n});\n</code></pre> <p>Since the elements are reloaded each time the immutability responsability is up to you because the source may change or if you generate objects it will generate new objects each time (so if you make strict comparison it will fail).</p>"},{"location":"structures/sequence/#lazystartingwith","title":"<code>::lazyStartingWith()</code>","text":"<p>Same as <code>::lazy()</code> except you don't need to manually build the generator.</p> <pre><code>$sequence = Sequence::lazyStartingWith(1, 2, 3);\n</code></pre> <p>This is useful when you know the first items of the sequence and you'll <code>append</code> another lazy sequence at the end.</p>"},{"location":"structures/sequence/#mixed","title":"<code>::mixed()</code>","text":"<p>This is a shortcut for <code>::of(mixed ...$mixed)</code>.</p>"},{"location":"structures/sequence/#ints","title":"<code>::ints()</code>","text":"<p>This is a shortcut for <code>::of(int ...$ints)</code>.</p>"},{"location":"structures/sequence/#floats","title":"<code>::floats()</code>","text":"<p>This is a shortcut for <code>::of(float ...$floats)</code>.</p>"},{"location":"structures/sequence/#strings","title":"<code>::strings()</code>","text":"<p>This is a shortcut for <code>::of(string ...$strings)</code>.</p>"},{"location":"structures/sequence/#objects","title":"<code>::objects()</code>","text":"<p>This is a shortcut for <code>::of(object ...$objects)</code>.</p>"},{"location":"structures/sequence/#add-values","title":"Add values","text":""},{"location":"structures/sequence/#-__invoke","title":"<code>-&gt;__invoke()</code>","text":"<p>Augment the sequence with a new element.</p> <pre><code>$sequence = Sequence::ints(1);\n$sequence = ($sequence)(2);\n$sequence-&gt;equals(Sequence::ints(1, 2));\n</code></pre>"},{"location":"structures/sequence/#-add","title":"<code>-&gt;add()</code>","text":"<p>This is an alias for <code>-&gt;__invoke()</code>.</p>"},{"location":"structures/sequence/#-append","title":"<code>-&gt;append()</code>","text":"<p>Add all elements of a sequence at the end of another.</p> <pre><code>$sequence = Sequence::ints(1, 2)-&gt;append(Sequence::ints(3, 4));\n$sequence-&gt;equals(Sequence::ints(1, 2, 3, 4)); // true\n</code></pre>"},{"location":"structures/sequence/#-prepend","title":"<code>-&gt;prepend()</code>","text":"<p>This is similar to <code>-&gt;append()</code> except the order is switched.</p> <p>The main advantage of this method is when using lazy sequences. If you want to add elements at the beginning of a sequence but the rest may be lazy then you need to create a lazy sequence with your values and then append the other lazy sequence; but this reveals the underlying lazyness of the call and you need to be aware that it could be lazy.</p> <p>Instead by using this method you no longer have to be aware that the other sequence is lazy or not.</p>"},{"location":"structures/sequence/#access-values","title":"Access values","text":""},{"location":"structures/sequence/#-size","title":"<code>-&gt;size()</code>","text":"<p>This returns the number of elements in the sequence.</p> <pre><code>$sequence = Sequence::ints(1, 4, 6);\n$sequence-&gt;size(); // 3\n</code></pre>"},{"location":"structures/sequence/#-count","title":"<code>-&gt;count()</code>","text":"<p>This is an alias for <code>-&gt;size()</code>, but you can also use the PHP function <code>\\count</code> if you prefer.</p> <pre><code>$sequence = Sequence::ints(1, 4, 6);\n$sequence-&gt;count(); // 3\n\\count($sequence); // 3\n</code></pre>"},{"location":"structures/sequence/#-get","title":"<code>-&gt;get()</code>","text":"<p>This method will return a <code>Maybe</code> object containing the element at the given index in the sequence. If the index doesn't exist it will an empty <code>Maybe</code> object.</p> <pre><code>$sequence = Sequence::ints(1, 4, 6);\n$sequence-&gt;get(1); // Maybe::just(4)\n$sequence-&gt;get(3); // Maybe::nothing()\n</code></pre>"},{"location":"structures/sequence/#-first","title":"<code>-&gt;first()</code>","text":"<p>This is an alias for <code>-&gt;get(0)</code>.</p>"},{"location":"structures/sequence/#-last","title":"<code>-&gt;last()</code>","text":"<p>This is an alias for <code>-&gt;get(-&gt;size() - 1)</code>.</p>"},{"location":"structures/sequence/#-contains","title":"<code>-&gt;contains()</code>","text":"<p>Check if the element is present in the sequence.</p> <pre><code>$sequence = Sequence::ints(1, 42, 3);\n$sequence-&gt;contains(2); // false\n$sequence-&gt;contains(42); // true\n$sequence-&gt;contains('42'); // false but psalm will raise an error\n</code></pre>"},{"location":"structures/sequence/#-indexof","title":"<code>-&gt;indexOf()</code>","text":"<p>This will return a <code>Maybe</code> object containing the index number at which the first occurence of the element was found.</p> <pre><code>$sequence = Sequence::ints(1, 2, 3, 2);\n$sequence-&gt;indexOf(2); // Maybe::just(1)\n$sequence-&gt;indexOf(4); // Maybe::nothing()\n</code></pre> Deprecated <p>This method will be remove in the next major version.</p>"},{"location":"structures/sequence/#-find","title":"<code>-&gt;find()</code>","text":"<p>Returns a <code>Maybe</code> object containing the first element that matches the predicate.</p> <pre><code>$sequence = Sequence::ints(2, 4, 6, 8, 9, 10, 11);\n$firstOdd = $sequence-&gt;find(fn($i) =&gt; $i % 2 === 1);\n$firstOdd; // Maybe::just(9)\n$sequence-&gt;find(static fn() =&gt; false); // Maybe::nothing()\n</code></pre>"},{"location":"structures/sequence/#-matches","title":"<code>-&gt;matches()</code>","text":"<p>Check if all the elements of the sequence matches the given predicate.</p> <pre><code>$isOdd = fn($i) =&gt; $i % 2 === 1;\nSequence::ints(1, 3, 5, 7)-&gt;matches($isOdd); // true\nSequence::ints(1, 3, 4, 5, 7)-&gt;matches($isOdd); // false\n</code></pre>"},{"location":"structures/sequence/#-any","title":"<code>-&gt;any()</code>","text":"<p>Check if at least one element of the sequence matches the given predicate.</p> <pre><code>$isOdd = fn($i) =&gt; $i % 2 === 1;\nSequence::ints(1, 3, 5, 7)-&gt;any($isOdd); // true\nSequence::ints(1, 3, 4, 5, 7)-&gt;any($isOdd); // true\nSequence::ints(2, 4, 6, 8)-&gt;any($isOdd); // false\n</code></pre>"},{"location":"structures/sequence/#-empty","title":"<code>-&gt;empty()</code>","text":"<p>Tells whether there is at least one element or not.</p> <pre><code>Sequence::ints()-&gt;empty(); // true\nSequence::ints(1)-&gt;empty(); // false\n</code></pre>"},{"location":"structures/sequence/#transform-values","title":"Transform values","text":""},{"location":"structures/sequence/#-map","title":"<code>-&gt;map()</code>","text":"<p>Create a new sequence with the exact same number of elements but modified by the given function.</p> <pre><code>$ints = Sequence::ints(1, 2, 3);\n$squares = $ints-&gt;map(fn($i) =&gt; $i**2);\n$squares-&gt;equals(Sequence::ints(1, 4, 9)); // true\n</code></pre>"},{"location":"structures/sequence/#-flatmap","title":"<code>-&gt;flatMap()</code>","text":"<p>This is similar to <code>-&gt;map()</code> except that instead of returning a new value it returns a new sequence for each value, and each new sequence is appended together.</p> <pre><code>$ints = Sequence::ints(1, 2, 3);\n$squares = $ints-&gt;flatMap(fn($i) =&gt; Sequence::of($i, $i**2));\n$squares-&gt;equals(Sequence::ints(1, 1, 2, 4, 3, 9)); // true\n</code></pre>"},{"location":"structures/sequence/#-via","title":"<code>-&gt;via()</code>","text":"<p>This method configures the <code>Sequence</code> via the provided callable. It allows a more fluent API when the code to modify the <code>Sequence</code> lies elsewhere and may be dynamic.</p> DoInstead of <pre><code>$doubles = static fn(Sequence $sequence) =&gt; $sequence-&gt;map(\n    static fn(int $i) =&gt; $i * 2,\n);\n\n$sequence = Sequence::of(1, 2, 3)\n    -&gt;via($doubles)\n    -&gt;via($doubles);\n</code></pre> <pre><code>$doubles = static fn(Sequence $sequence) =&gt; $sequence-&gt;map(\n    static fn(int $i) =&gt; $i * 2,\n);\n\n$sequence = $doubles(\n    $doubles(\n        Sequence::of(1, 2, 3),\n    ),\n);\n</code></pre> <p>In both cases it returns <code>Sequence::of(4, 8, 12)</code>, but <code>-&gt;via()</code> offers a more readable experience.</p> Tip <p>For lazy sequences the callable will be called everytime you call un unwrapping method .</p> <p>This allows to have stateful configuration.</p> <p>If you want the callable to be called once you need to use this strategy instead:</p> <pre><code>$sequence = Sequence::lazy($generator)\n    -&gt;toIdentity()\n    -&gt;map($doubles)\n    -&gt;map($doubles)\n    -&gt;unwrap();\n</code></pre>"},{"location":"structures/sequence/#-zip","title":"<code>-&gt;zip()</code>","text":"<p>This method allows to merge 2 sequences into a new one by combining the values of the 2 into pairs.</p> <pre><code>$firnames = Sequence::of('John', 'Luke', 'James');\n$lastnames = Sequence::of('Doe', 'Skywalker', 'Kirk');\n\n$pairs = $firnames\n    -&gt;zip($lastnames)\n    -&gt;toList();\n$pairs; // [['John', 'Doe'], ['Luke', 'Skywalker'], ['James', 'Kirk']]\n</code></pre>"},{"location":"structures/sequence/#-aggregate","title":"<code>-&gt;aggregate()</code>","text":"<p>This methods allows to rearrange the elements of the Sequence. This is especially useful for parsers.</p> <p>An example would be to rearrange a list of chunks from a file into lines:</p> <pre><code>// let's pretend this comes from a stream\n$chunks = ['fo', \"o\\n\", 'ba', \"r\\n\", 'ba', \"z\\n\"];\n$lines = Sequence::of(...$chunks)\n    -&gt;map(Str::of(...))\n    -&gt;aggregate(static fn($a, $b) =&gt; $a-&gt;append($b-&gt;toString())-&gt;split(\"\\n\"))\n    -&gt;flatMap(static fn($chunk) =&gt; $chunk-&gt;split(\"\\n\"))\n    -&gt;map(static fn($line) =&gt; $line-&gt;toString())\n    -&gt;toList();\n$lines; // ['foo', 'bar', 'baz', '']\n</code></pre> <p>The <code>flatMap</code> is here in case there is only one chunk in the sequence, in which case the <code>aggregate</code> is not called</p>"},{"location":"structures/sequence/#-chunk","title":"<code>-&gt;chunk()</code>","text":"<p>This is a shortcut over <code>aggregate</code>. The same example can be shortened:</p> <pre><code>// let's pretend this comes from a stream\n$chunks = ['fo', \"o\\n\", 'ba', \"r\\n\", 'ba', \"z\\n\"];\n$lines = Sequence::of(...$chunks)\n    -&gt;map(Str::of(...))\n    -&gt;map(\n        static fn($chunk) =&gt; $chunk\n            -&gt;toEncoding(Str\\Encoding::ascii)\n            -&gt;split(),\n    )\n    -&gt;chunk(4)\n    -&gt;map(static fn($chars) =&gt; $chars-&gt;dropEnd(1)) // to remove \"\\n\"\n    -&gt;map(Str::of('')-&gt;join(...))\n    -&gt;map(static fn($line) =&gt; $line-&gt;toString())\n    -&gt;toList();\n$lines; // ['foo', 'bar', 'baz', '']\n</code></pre> <p>This better accomodates to the case where the initial <code>Sequence</code> only contains a single value.</p>"},{"location":"structures/sequence/#-windows","title":"<code>-&gt;windows()</code>","text":"<p>This returns a sliding window (of fixed size) across all values. This is useful when parsing a Sequence of values to find an end flag that's spread across multiple values.</p> <pre><code>$values = Sequence::of('l', 'o', 'r', 'e', 'm', 'i', 'p', 's', 'u', 'm');\n$values-&gt;windows(3)-&gt;equals(\n    Sequence::of(\n        Sequence::of('l', 'o', 'r'),\n        Sequence::of('o', 'r', 'e'),\n        Sequence::of('r', 'e', 'm'),\n        Sequence::of('e', 'm', 'i'),\n        Sequence::of('m', 'i', 'p'),\n        Sequence::of('i', 'p', 's'),\n        Sequence::of('p', 's', 'u'),\n        Sequence::of('s', 'u', 'm'),\n    )\n); // true\n\n$values\n    -&gt;windows(2)\n    -&gt;takeWhile(static fn($window) =&gt; !$window-&gt;equals(Sequence::of('i', 'p')))\n    -&gt;flatMap(static fn($window) =&gt; $window-&gt;take(1))\n    -&gt;equals(Sequence::of('l', 'o', 'r', 'e', 'm')); // true\n</code></pre> <p>If the source <code>Sequence</code> contains less values than the specified size then it will return a window shorter than the specified size.</p> <pre><code>Sequence::of('a', 'b', 'c')-&gt;windows(10)-&gt;equals(\n    Sequence::of(\n        Sequence::of('a', 'b', 'c'),\n    ),\n); // true\n</code></pre>"},{"location":"structures/sequence/#-indices","title":"<code>-&gt;indices()</code>","text":"<p>Create a new sequence of integers representing the indices of the original sequence.</p> <pre><code>$sequence = Sequence::ints(1, 2, 3);\n$sequence-&gt;indices()-&gt;equals(Sequence::ints(...\\range(0, $sequence-&gt;size() - 1)));\n</code></pre>"},{"location":"structures/sequence/#filter-values","title":"Filter values","text":""},{"location":"structures/sequence/#-filter","title":"<code>-&gt;filter()</code>","text":"<p>Removes elements from the sequence that don't match the given predicate.</p> <pre><code>$sequence = Sequence::ints(1, 2, 3, 4)-&gt;filter(fn($i) =&gt; $i % 2 === 0);\n$sequence-&gt;equals(Sequence::ints(2, 4));\n</code></pre>"},{"location":"structures/sequence/#-keep","title":"<code>-&gt;keep()</code>","text":"<p>This is similar to <code>-&gt;filter()</code> with the advantage of psalm understanding the type in the new <code>Sequence</code>.</p> <pre><code>use Innmind\\Immutable\\Predicate\\Instance;\n\n$sequence = Sequence::of(null, new \\stdClass, 'foo')-&gt;keep(\n    Instance::of('stdClass'),\n);\n$sequence; // Sequence&lt;stdClass&gt;\n</code></pre>"},{"location":"structures/sequence/#-exclude","title":"<code>-&gt;exclude()</code>","text":"<p>Removes elements from the sequence that match the given predicate.</p> <pre><code>$sequence = Sequence::ints(1, 2, 3, 4)-&gt;filter(fn($i) =&gt; $i % 2 === 0);\n$sequence-&gt;equals(Sequence::ints(1, 3));\n</code></pre>"},{"location":"structures/sequence/#-take","title":"<code>-&gt;take()</code>","text":"<p>Create a new sequence with only the given number of elements from the start of the sequence.</p> <pre><code>Sequence::ints(4, 3, 1, 0)-&gt;take(2)-&gt;equals(Sequence::ints(4, 3)); // true\n</code></pre>"},{"location":"structures/sequence/#-takeend","title":"<code>-&gt;takeEnd()</code>","text":"<p>Similar to <code>-&gt;take()</code> but it starts from the end of the sequence</p> <pre><code>Sequence::ints(4, 3, 1, 0)-&gt;takeEnd(2)-&gt;equals(Sequence::ints(1, 0)); // true\n</code></pre>"},{"location":"structures/sequence/#-takewhile","title":"<code>-&gt;takeWhile()</code>","text":"<p>This keeps all the elements from the start of the sequence while the condition returns <code>true</code>.</p> <pre><code>$values = Sequence::of(1, 2, 3, 0, 4, 5, 6, 0)\n    -&gt;takeWhile(static fn($i) =&gt; $i === 0)\n    -&gt;toList();\n$values === [1, 2, 3];\n</code></pre>"},{"location":"structures/sequence/#-drop","title":"<code>-&gt;drop()</code>","text":"<p>This removes the number of elements from the end of the sequence.</p> <pre><code>$sequence = Sequence::ints(5, 4, 3, 2, 1)-&gt;drop(2);\n$sequence-&gt;equals(Sequence::ints(3, 2, 1)); // true\n</code></pre>"},{"location":"structures/sequence/#-dropend","title":"<code>-&gt;dropEnd()</code>","text":"<p>This removes the number of elements from the end of the sequence.</p> <pre><code>$sequence = Sequence::ints(1, 2, 3, 4, 5)-&gt;drop(2);\n$sequence-&gt;equals(Sequence::ints(1, 2, 3)); // true\n</code></pre>"},{"location":"structures/sequence/#-dropwhile","title":"<code>-&gt;dropWhile()</code>","text":"<p>This removes all the elements from the start of the sequence while the condition returns <code>true</code>.</p> <pre><code>$values = Sequence::of(0, 0, 0, 1, 2, 3, 0)\n    -&gt;dropWhile(static fn($i) =&gt; $i === 0)\n    -&gt;toList();\n$values === [1, 2, 3, 0];\n</code></pre>"},{"location":"structures/sequence/#-slice","title":"<code>-&gt;slice()</code>","text":"<p>Return a new sequence with only the elements that were between the given indices. (The upper bound is not included)</p> <pre><code>$sequence = Sequence::ints(4, 3, 2, 1);\n$sequence-&gt;slice(1, 4)-&gt;equals(Sequence::ints(3, 2)); // true\n</code></pre>"},{"location":"structures/sequence/#-diff","title":"<code>-&gt;diff()</code>","text":"<p>This method will return a new sequence containing the elements that are not present in the other sequence.</p> <pre><code>$sequence = Sequence::ints(1, 4, 6)-&gt;diff(Sequence::ints(1, 3, 6));\n$sequence-&gt;equals(Sequence::ints(4)); // true\n</code></pre>"},{"location":"structures/sequence/#-intersect","title":"<code>-&gt;intersect()</code>","text":"<p>Create a new sequence with the elements that are also in the other sequence.</p> <pre><code>$sequence = Sequence::ints(1, 2, 3)-&gt;intersect(Sequence::ints(2, 3, 4));\n$sequence-&gt;equals(Sequence::ints(2, 3)); // true\n</code></pre>"},{"location":"structures/sequence/#-distinct","title":"<code>-&gt;distinct()</code>","text":"<p>This removes any duplicates in the sequence.</p> <pre><code>$sequence = Sequence::ints(1, 2, 1, 3)-&gt;distinct();\n$sequence-&gt;equals(Sequence::ints(1, 2, 3)); // true\n</code></pre>"},{"location":"structures/sequence/#extract-values","title":"Extract values","text":""},{"location":"structures/sequence/#-tolist","title":"<code>-&gt;toList()</code>","text":"<p>It returns a new <code>array</code> containing all the elements of the sequence.</p>"},{"location":"structures/sequence/#-match","title":"<code>-&gt;match()</code>","text":"<p>This is a similar approach to pattern matching allowing you to decompose a sequence by accessing the first element and the rest of the sequence.</p> <pre><code>function sum(Sequence $ints): int\n{\n    return $ints-&gt;match(\n        fn(int $head, Sequence $tail) =&gt; $head + sum($tail),\n        fn() =&gt; 0,\n    );\n}\n\n$result = sum(Sequence::of(1, 2, 3, 4));\n$result; // 10\n</code></pre> <p>For lazy sequences bear in mind that the values will be kept in memory while the first call to <code>-&gt;match</code> didn't return.</p>"},{"location":"structures/sequence/#-fold","title":"<code>-&gt;fold()</code>","text":"<p>This is similar to the <code>reduce</code> method but only takes a <code>Monoid</code> as an argument.</p> <pre><code>use Innmind\\Immutable\\Monoid\\Concat;\n\n$lines = Sequence::of(\"foo\\n\", \"bar\\n\", 'baz')\n    -&gt;map(fn($line) =&gt; Str::of($line))\n    -&gt;fold(new Concat);\n\n$lines-&gt;equals(\"foo\\nbar\\nbaz\"); // true\n</code></pre>"},{"location":"structures/sequence/#-reduce","title":"<code>-&gt;reduce()</code>","text":"<p>Iteratively compute a value for all the elements in the sequence.</p> <pre><code>$sequence = Sequence::ints(1, 2, 3, 4);\n$sum = $sequence-&gt;reduce(0, fn($sum, $int) =&gt; $sum + $int);\n$sum; // 10\n</code></pre>"},{"location":"structures/sequence/#-sink","title":"<code>-&gt;sink()</code>","text":"<p>This is similar to <code>-&gt;reduce</code> except you decide on each iteration it you want to continue reducing or not.</p> <p>This is useful for long sequences (mainly lazy ones) where you need to reduce until you find some value in the <code>Sequence</code> or the reduced value matches some condition. This avoids iterating over values you know for sure you won't need.</p> By handMaybeEitherAttempt <pre><code>use Innmind\\Immutable\\Sequence\\Sink\\Continuation;\n\n$sequence = Sequence::of(1, 2, 3, 4, 5);\n$sum = $sequence\n    -&gt;sink(0)\n    -&gt;until(static fn(\n        int $sum,\n        int $i,\n        Continuation $continuation,\n    ) =&gt; match (true) {\n        $sum &gt; 5 =&gt; $continuation-&gt;stop($sum),\n        default =&gt; $continuation-&gt;continue($sum + $i),\n    });\n</code></pre> <p>Here <code>$sum</code> is <code>6</code> and the <code>Sequence</code> stopped iterating on the 4th value.</p> <pre><code>$sequence = Sequence::of(1, 2, 3, 4, 5);\n$sum = $sequence\n    -&gt;sink(0)\n    -&gt;maybe(static fn(int $sum, int $i) =&gt; match (true) {\n        $sum &gt; 5 =&gt; Maybe::nothing(),\n        default =&gt; Maybe::just($sum + $i),\n    })\n    -&gt;match(\n        static fn(int $sum) =&gt; $sum,\n        static fn() =&gt; null,\n    );\n</code></pre> <p>Instead of manually specifying if we want to continue or not, it's inferred by the content of the <code>Maybe</code>.</p> <p>Here the <code>$sum</code> is <code>null</code> because on the 4th iteration we return a <code>Maybe::nothing()</code>.</p> <p>Bear in mind that the carried value is lost when an iteration returns <code>Maybe::nothing()</code>.</p> <p>If you need to still have access to the carried value you should use <code>-&gt;sink()-&gt;either()</code> and place the carried value on the left side.</p> Abstract <p>In essence this allows the transformation of <code>Sequence&lt;Maybe&lt;T&gt;&gt;</code> to <code>Maybe&lt;Sequence&lt;T&gt;&gt;</code>.</p> <pre><code>$sequence = Sequence::of(1, 2, 3, 4, 5);\n$sum = $sequence\n    -&gt;sink(0)\n    -&gt;either(static fn(int $sum, int $i) =&gt; match (true) {\n        $sum &gt; 5 =&gt; Either::left($sum),\n        default =&gt; Either::right($sum + $i),\n    })\n    -&gt;match(\n        static fn(int $sum) =&gt; $sum,\n        static fn(int $sum) =&gt; $sum,\n    );\n</code></pre> <p>Instead of manually specifying if we want to continue or not, it's inferred by the content of the <code>Either</code>.</p> <p>Here the <code>$sum</code> is <code>6</code> because on the 4th iteration we return an <code>Either::left()</code> with the carried sum from the previous iteration.</p> Abstract <p>In essence this allows the transformation of <code>Sequence&lt;Either&lt;E, T&gt;&gt;</code> to <code>Either&lt;E, Sequence&lt;T&gt;&gt;</code>.</p> <pre><code>$sequence = Sequence::of(1, 2, 3, 4, 5);\n$sum = $sequence\n    -&gt;sink(0)\n    -&gt;attempt(static fn(int $sum, int $i) =&gt; match (true) {\n        $sum &gt; 5 =&gt; Attempt::error(new \\Exception('sum too high')),\n        default =&gt; Attempt::result($sum + $i),\n    })\n    -&gt;match(\n        static fn(int $sum) =&gt; $sum,\n        static fn(\\Exception $e) =&gt; null,\n    );\n</code></pre> <p>Instead of manually specifying if we want to continue or not, it's inferred by the content of the <code>Attempt</code>.</p> <p>Here the <code>$sum</code> is <code>null</code> because on the 4th iteration we return a <code>Attempt::error()</code>.</p> <p>Bear in mind that the carried value is lost when an iteration returns <code>Attempt::error()</code>. Unless you attach the value to the exception.</p> Abstract <p>In essence this allows the transformation of <code>Sequence&lt;Attempt&lt;T&gt;&gt;</code> to <code>Attempt&lt;Sequence&lt;T&gt;&gt;</code>.</p>"},{"location":"structures/sequence/#misc","title":"Misc.","text":""},{"location":"structures/sequence/#-equals","title":"<code>-&gt;equals()</code>","text":"<p>Check if two sequences are identical.</p> <pre><code>Sequence::ints(1, 2)-&gt;equals(Sequence::ints(1, 2)); // true\nSequence::ints()-&gt;equals(Sequence::strings()); // false but psalm will raise an error\n</code></pre>"},{"location":"structures/sequence/#-foreach","title":"<code>-&gt;foreach()</code>","text":"<p>Use this method to call a function for each element of the sequence. Since this structure is immutable it returns a <code>SideEffect</code> object, as its name suggest it is the only place acceptable to create side effects.</p> <pre><code>$sideEffect = Sequence::strings('hello', 'world')-&gt;foreach(\n    function(string $string): void {\n        echo $string.' ';\n    },\n);\n</code></pre> <p>In itself the <code>SideEffect</code> object has no use except to avoid psalm complaining that the <code>foreach</code> method is not used.</p>"},{"location":"structures/sequence/#-groupby","title":"<code>-&gt;groupBy()</code>","text":"<p>This will create multiples sequences with elements regrouped under the same key computed by the given function.</p> <pre><code>$urls = Sequence::strings(\n    'http://example.com',\n    'http://example.com/foo',\n    'https://example.com',\n    'ftp://example.com',\n);\n/** @var Innmind\\Immutable\\Map&lt;string, Sequence&lt;string&gt;&gt; */\n$map = $urls-&gt;groupBy(fn(string $url): string =&gt; \\parse_url($url)['scheme']);\n$map\n    -&gt;get('http')\n    -&gt;match(\n        static fn($group) =&gt; $group,\n        static fn() =&gt; Sequence::strings(),\n    )\n    -&gt;equals(Sequence::strings(\n        'http://example.com',\n        'http://example.com/foo',\n    )); // true\n$map\n    -&gt;get('https')\n    -&gt;match(\n        static fn($group) =&gt; $group,\n        static fn() =&gt; Sequence::strings(),\n    )\n    -&gt;equals(Sequence::strings('https://example.com')); // true\n$map\n    -&gt;get('ftp')\n    -&gt;match(\n        static fn($group) =&gt; $group,\n        static fn() =&gt; Sequence::strings(),\n    )\n    -&gt;equals(Sequence::strings('ftp://example.com')); // true\n</code></pre>"},{"location":"structures/sequence/#-pad","title":"<code>-&gt;pad()</code>","text":"<p>Add the same element to a new sequence in order that its size is at least the given one.</p> <pre><code>$sequence = Sequence::ints(1, 2, 3);\n$sequence-&gt;pad(2, 0)-&gt;equals(Sequence::ints(1, 2, 3)); // true\n$sequence-&gt;pad(5, 0)-&gt;equals(Sequence::ints(1, 2, 3, 0, 0)); // true\n</code></pre>"},{"location":"structures/sequence/#-partition","title":"<code>-&gt;partition()</code>","text":"<p>This method is similar to <code>-&gt;groupBy()</code> method but the map keys are always booleans. The difference is that here the 2 keys are always present whereas with <code>-&gt;groupBy()</code> it will depend on the original sequence.</p> <pre><code>$sequence = Sequence::ints(1, 2, 3);\n/** @var Map&lt;bool, Sequence&lt;int&gt;&gt; */\n$map = $sequence-&gt;partition(fn($int) =&gt; $int % 2 === 0);\n$map\n    -&gt;get(true)\n    -&gt;match(\n        static fn($partition) =&gt; $partition,\n        static fn() =&gt; Sequence::ints(),\n    )\n    -&gt;equals(Sequence::ints(2)); // true\n$map\n    -&gt;get(false)\n    -&gt;match(\n        static fn($partition) =&gt; $partition,\n        static fn() =&gt; Sequence::ints(),\n    )\n    -&gt;equals(Sequence::ints(1, 3)); // true\n</code></pre>"},{"location":"structures/sequence/#-sort","title":"<code>-&gt;sort()</code>","text":"<p>Reorder the elements within the sequence.</p> <pre><code>$sequence = Sequence::ints(4, 2, 3, 1);\n$sequence = $sequence-&gt;sort(fn($a, $b) =&gt; $a &lt;=&gt; $b);\n$sequence-&gt;equals(Sequence::ints(1, 2, 3, 4));\n</code></pre>"},{"location":"structures/sequence/#-clear","title":"<code>-&gt;clear()</code>","text":"<p>Create an empty new sequence of the same type. (To avoid to redeclare the types manually in a docblock)</p> <pre><code>$sequence = Sequence::ints(1);\n$sequence-&gt;clear()-&gt;size(); // 0\n</code></pre>"},{"location":"structures/sequence/#-reverse","title":"<code>-&gt;reverse()</code>","text":"<p>Create a new sequence where the last element become the first one and so on.</p> <pre><code>$sequence = Sequence::ints(1, 2, 3, 4);\n$sequence-&gt;reverse()-&gt;equals(Sequence::ints(4, 3, 2, 1));\n</code></pre>"},{"location":"structures/sequence/#-toset","title":"<code>-&gt;toSet()</code>","text":"<p>It's like <code>-&gt;distinct()</code> except it returns a <code>Set</code> instead of a <code>Sequence</code>.</p>"},{"location":"structures/sequence/#-toidentity","title":"<code>-&gt;toIdentity()</code>","text":"<p>This method wraps the sequence in an <code>Identity</code> monad.</p> <p>Let's say you have a sequence of strings representing the parts of a file and you want to build a file object:</p> DoInstead of... <pre><code>$file = Sequence::of('a', 'b', 'c', 'etc...')\n    -&gt;toIdentity()\n    -&gt;map(Content::ofChunks(...))\n    -&gt;map(static fn($content) =&gt; File::named('foo', $content))\n    -&gt;unwrap();\n</code></pre> <pre><code>$file = File::named(\n    'foo',\n    Content::ofChunks(\n        Sequence::of('a', 'b', 'c', 'etc...'),\n    ),\n);\n</code></pre> Note <p>Here <code>Content</code> and <code>File</code> are imaginary classes, but you can find equivalent classes in <code>innmind/filesystem</code>.</p> Tip <p>The <code>Identity</code> returned carries the lazyness of the sequence. This allows composing sequences without having to be aware if the source is lazy or not.</p> LazyInMemory <pre><code>$value = Sequence::lazy(static fn() =&gt; yield from \\range(0, 100))\n    -&gt;toIdentity()\n    -&gt;toSequence();\n// does the same as\n$value = Sequence::lazy(\n    static fn() =&gt; yield Sequence::lazy(\n        static fn() =&gt; yield from \\range(0, 100),\n    ),\n);\n</code></pre> <pre><code>$value = Sequence::of(...\\range(0, 100))\n    -&gt;toIdentity()\n    -&gt;toSequence();\n// does the same as\n$value = Sequence::of(\n    Sequence::of(\n        ...\\range(0, 100),\n    ),\n);\n</code></pre> <p>In both cases thanks to the <code>Identity</code> you only need to specify once if the whole thing is lazy or not.</p>"},{"location":"structures/sequence/#-safeguard","title":"<code>-&gt;safeguard()</code>","text":"<p>This method allows you to make sure all values conforms to an assertion before continuing using the sequence.</p> <pre><code>$uniqueFiles = Sequence::of('a', 'b', 'c', 'a')\n    -&gt;safeguard(\n        Set::strings()\n        static fn(Set $names, string $name) =&gt; match ($names-&gt;contains($name)) {\n            true =&gt; throw new \\LogicException(\"$name is already used\"),\n            false =&gt; $names-&gt;add($name),\n        },\n    );\n</code></pre> <p>This example will throw because there is the value <code>a</code> twice.</p> <p>This method is especially useful for deferred or lazy sequences because it allows to make sure all values conforms after this call whithout unwrapping the whole sequence first. The downside of this lazy evaluation is that some operations may start before reaching a non conforming value (example below).</p> <pre><code>Sequence::lazyStartingWith('a', 'b', 'c', 'a')\n    -&gt;safeguard(\n        Set::strings()\n        static fn(Set $names, string $name) =&gt; match ($names-&gt;contains($name)) {\n            true =&gt; throw new \\LogicException(\"$name is already used\"),\n            false =&gt; $names-&gt;add($name),\n        },\n    )\n    -&gt;foreach(static fn($name) =&gt; print($name));\n</code></pre> <p>This example will print <code>a</code>, <code>b</code> and <code>c</code> before throwing an exception because of the second <code>a</code>. Use this method carefully.</p>"},{"location":"structures/sequence/#-memoize","title":"<code>-&gt;memoize()</code>","text":"<p>This method will load all the values in memory. This is useful only for a deferred or lazy <code>Sequence</code>, the other sequence will be unaffected.</p> <pre><code>$sequence = Sequence::lazy(function() {\n    $stream = \\fopen('some-file', 'r');\n    while (!\\feof($stream)) {\n        yield \\fgets($stream);\n    }\n})\n    -&gt;map(static fn($line) =&gt; \\strtoupper($line)) // still no line loaded here\n    -&gt;memoize(); // load all lines and apply strtoupper on each\n</code></pre>"},{"location":"structures/sequence/#-snap","title":"<code>-&gt;snap()</code>","text":"<p>This method indicates that the <code>Sequence</code> will be memoized when a method that needs to load the data is called.</p> <pre><code>$sequence = Sequence::lazy(function() {\n    $stream = \\fopen('some-file', 'r');\n    while (!\\feof($stream)) {\n        yield \\fgets($stream);\n    }\n})\n    -&gt;map(static fn($line) =&gt; \\trim($line, \"\\n\"))\n    -&gt;exclude(static fn($line) =&gt; $line === '')\n    -&gt;snap()\n    -&gt;map(static fn($line) =&gt; \\strtoupper($line)); // still no line loaded here\n</code></pre> <p>Unlike <code>-&gt;memoize()</code>, if no code after this needs to access the data then nothing is loaded but it some does then it will load all non empty lines at once.</p>"},{"location":"structures/set/","title":"<code>Set</code>","text":"<p>A set is an unordered list of unique elements.</p>"},{"location":"structures/set/#named-constructors","title":"Named constructors","text":""},{"location":"structures/set/#of","title":"<code>::of()</code>","text":"<pre><code>use Innmind\\Immutable\\Set;\n\n/** @var Set&lt;int&gt; */\nSet::of(1, 2, 3, $etc);\n</code></pre>"},{"location":"structures/set/#defer","title":"<code>::defer()</code>","text":"<p>This named constructor is for advanced use cases where you want the data of your set to be loaded upon use only and not initialisation.</p> <p>An example for such a use case is a set of log lines coming from a file:</p> <pre><code>$set = Set::defer((function() {\n    yield from readSomeFile('apache.log');\n})());\n</code></pre> <p>The method ask a generator that will provide the elements. Once the elements are loaded they are kept in memory so you can run multiple operations on it without loading the file twice.</p> <p>Beware of the case where the source you read the elements is not altered before the first use of the set.</p> Deprecated <p>This constructor is deprecated. You should use <code>Set::lazy()-&gt;snap()</code> instead.</p>"},{"location":"structures/set/#lazy","title":"<code>::lazy()</code>","text":"<p>This is similar to <code>::defer()</code> with the exception that the elements are not kept in memory but reloaded upon each use.</p> <pre><code>$set = Set::lazy(function() {\n    yield from readSomeFile('apache.log');\n});\n</code></pre> <p>Since the elements are reloaded each time the immutability responsability is up to you because the source may change or if you generate objects it will generate new objects each time (so if you make strict comparison it will fail).</p>"},{"location":"structures/set/#mixed","title":"<code>::mixed()</code>","text":"<p>This is a shortcut for <code>::of(mixed ...$mixed)</code>.</p>"},{"location":"structures/set/#ints","title":"<code>::ints()</code>","text":"<p>This is a shortcut for <code>::of(int ...$ints)</code>.</p>"},{"location":"structures/set/#floats","title":"<code>::floats()</code>","text":"<p>This is a shortcut for <code>::of(float ...$floats)</code>.</p>"},{"location":"structures/set/#strings","title":"<code>::strings()</code>","text":"<p>This is a shortcut for <code>::of(string ...$strings)</code>.</p>"},{"location":"structures/set/#objects","title":"<code>::objects()</code>","text":"<p>This is a shortcut for <code>::of(object ...$objects)</code>.</p>"},{"location":"structures/set/#add-values","title":"Add values","text":""},{"location":"structures/set/#-__invoke","title":"<code>-&gt;__invoke()</code>","text":"<p>Augment the set with a new element. If the element is already in the set nothing changes.</p> <pre><code>$set = Set::ints(1);\n$set = ($set)(2)(1);\n$set-&gt;equals(Set::ints(1, 2));\n</code></pre>"},{"location":"structures/set/#-add","title":"<code>-&gt;add()</code>","text":"<p>This is an alias for <code>-&gt;__invoke()</code>.</p>"},{"location":"structures/set/#-merge","title":"<code>-&gt;merge()</code>","text":"<p>Create a new set with all the elements from both sets.</p> <pre><code>$set = Set::ints(1, 2, 3)-&gt;merge(Set::ints(4, 2, 3));\n$set-&gt;equals(Set::ints(1, 2, 3, 4));\n</code></pre>"},{"location":"structures/set/#access-values","title":"Access values","text":""},{"location":"structures/set/#-size","title":"<code>-&gt;size()</code>","text":"<p>This returns the number of elements in the set.</p> <pre><code>$set = Set::ints(1, 4, 6);\n$set-&gt;size(); // 3\n</code></pre>"},{"location":"structures/set/#-count","title":"<code>-&gt;count()</code>","text":"<p>This is an alias for <code>-&gt;size()</code>, but you can also use the PHP function <code>\\count</code> if you prefer.</p> <pre><code>$set = Set::ints(1, 4, 6);\n$set-&gt;count(); // 3\n\\count($set); // 3\n</code></pre>"},{"location":"structures/set/#-contains","title":"<code>-&gt;contains()</code>","text":"<p>Check if the element is present in the set.</p> <pre><code>$set = Set::ints(1, 42, 3);\n$set-&gt;contains(2); // false\n$set-&gt;contains(42); // true\n$set-&gt;contains('42'); // false but psalm will raise an error\n</code></pre>"},{"location":"structures/set/#-find","title":"<code>-&gt;find()</code>","text":"<p>Returns the first element that matches the predicate.</p> <pre><code>$set = Set::ints(2, 4, 6, 8, 9, 10, 11);\n/** @var Maybe&lt;int&gt; $firstOdd */\n$firstOdd = $set-&gt;find(fn($i) =&gt; $i % 2 === 1);\n$firstOdd; // could contain 9 or 11, because there is no ordering\n</code></pre>"},{"location":"structures/set/#-matches","title":"<code>-&gt;matches()</code>","text":"<p>Check if all the elements of the set matches the given predicate.</p> <pre><code>$isOdd = fn($i) =&gt; $i % 2 === 1;\nSet::ints(1, 3, 5, 7)-&gt;matches($isOdd); // true\nSet::ints(1, 3, 4, 5, 7)-&gt;matches($isOdd); // false\n</code></pre>"},{"location":"structures/set/#-any","title":"<code>-&gt;any()</code>","text":"<p>Check if at least one element of the set matches the given predicate.</p> <pre><code>$isOdd = fn($i) =&gt; $i % 2 === 1;\nSet::ints(1, 3, 5, 7)-&gt;any($isOdd); // true\nSet::ints(1, 3, 4, 5, 7)-&gt;any($isOdd); // true\nSet::ints(2, 4, 6, 8)-&gt;any($isOdd); // false\n</code></pre>"},{"location":"structures/set/#-empty","title":"<code>-&gt;empty()</code>","text":"<p>Tells whether there is at least one element or not.</p> <pre><code>Set::ints()-&gt;empty(); // true\nSet::ints(1)-&gt;empty(); // false\n</code></pre>"},{"location":"structures/set/#transform-values","title":"Transform values","text":""},{"location":"structures/set/#-map","title":"<code>-&gt;map()</code>","text":"<p>Create a new set with the exact same number of elements but modified by the given function.</p> <pre><code>$ints = Set::ints(1, 2, 3);\n$squares = $ints-&gt;map(fn($i) =&gt; $i**2);\n$squares-&gt;equals(Set::ints(1, 4, 9)); // true\n</code></pre>"},{"location":"structures/set/#-flatmap","title":"<code>-&gt;flatMap()</code>","text":"<p>This is similar to <code>-&gt;map()</code> except that instead of returning a new value it returns a new set for each value, and each new set is merged together.</p> <pre><code>$ints = Set::ints(1, 2, 3);\n$squares = $ints-&gt;flatMap(fn($i) =&gt; Set::of($i, $i**2));\n$squares-&gt;equals(Set::ints(1, 2, 4, 3, 9)); // true\n</code></pre>"},{"location":"structures/set/#filter-values","title":"Filter values","text":""},{"location":"structures/set/#-remove","title":"<code>-&gt;remove()</code>","text":"<p>Create a new set without the specified element.</p> <pre><code>$set = Set::ints(1, 2, 3);\n$set-&gt;remove(2)-&gt;equals(Set::ints(1, 3)); // true\n</code></pre>"},{"location":"structures/set/#-filter","title":"<code>-&gt;filter()</code>","text":"<p>Removes elements from the set that don't match the given predicate.</p> <pre><code>$set = Set::ints(1, 2, 3, 4)-&gt;filter(fn($i) =&gt; $i % 2 === 0);\n$set-&gt;equals(Set::ints(2, 4));\n</code></pre>"},{"location":"structures/set/#-keep","title":"<code>-&gt;keep()</code>","text":"<p>This is similar to <code>-&gt;filter()</code> with the advantage of psalm understanding the type in the new <code>Set</code>.</p> <pre><code>use Innmind\\Immutable\\Predicate\\Instance;\n\n$set = Set::of(null, new \\stdClass, 'foo')-&gt;keep(Instance::of('stdClass'));\n$set; // Set&lt;stdClass&gt;\n</code></pre>"},{"location":"structures/set/#-exclude","title":"<code>-&gt;exclude()</code>","text":"<p>Removes elements from the set that match the given predicate.</p> <pre><code>$set = Set::ints(1, 2, 3, 4)-&gt;filter(fn($i) =&gt; $i % 2 === 0);\n$set-&gt;equals(Set::ints(1, 3));\n</code></pre>"},{"location":"structures/set/#-diff","title":"<code>-&gt;diff()</code>","text":"<p>This method will return a new set containing the elements that are not present in the other set.</p> <pre><code>$set = Set::ints(1, 4, 6)-&gt;diff(Set::ints(1, 3, 6));\n$set-&gt;equals(Set::ints(4)); // true\n</code></pre>"},{"location":"structures/set/#-intersect","title":"<code>-&gt;intersect()</code>","text":"<p>Create a new set with the elements that are also in the other set.</p> <pre><code>$set = Set::ints(1, 2, 3)-&gt;intersect(Set::ints(2, 3, 4));\n$set-&gt;equals(Set::ints(2, 3)); // true\n</code></pre>"},{"location":"structures/set/#extract-values","title":"Extract values","text":""},{"location":"structures/set/#-tolist","title":"<code>-&gt;toList()</code>","text":"<p>It returns a new <code>array</code> containing all the elements of the set.</p>"},{"location":"structures/set/#-match","title":"<code>-&gt;match()</code>","text":"<p>This is a similar approach to pattern matching allowing you to decompose a set by accessing the first element and the rest of the set.</p> <pre><code>function sum(Set $ints): int\n{\n    return $ints-&gt;match(\n        fn(int $head, Set $tail) =&gt; $head + sum($tail),\n        fn() =&gt; 0,\n    );\n}\n\n$result = sum(Set::of(1, 2, 3, 4));\n$result; // 10\n</code></pre> <p>For lazy sets bear in mind that the values will be kept in memory while the first call to <code>-&gt;match</code> didn't return.</p>"},{"location":"structures/set/#-reduce","title":"<code>-&gt;reduce()</code>","text":"<p>Iteratively compute a value for all the elements in the set.</p> <pre><code>$set = Set::ints(1, 2, 3, 4);\n$sum = $set-&gt;reduce(0, fn($sum, $int) =&gt; $sum + $int);\n$sum; // 10\n</code></pre>"},{"location":"structures/set/#misc","title":"Misc.","text":""},{"location":"structures/set/#-equals","title":"<code>-&gt;equals()</code>","text":"<p>Check if two sets are identical.</p> <pre><code>Set::ints(1, 2)-&gt;equals(Set::ints(2, 1)); // true\nSet::ints()-&gt;equals(Set::strings()); // false but psalm will raise an error\n</code></pre>"},{"location":"structures/set/#-foreach","title":"<code>-&gt;foreach()</code>","text":"<p>Use this method to call a function for each element of the set. Since this structure is immutable it returns a <code>SideEffect</code> object, as its name suggest it is the only place acceptable to create side effects.</p> <pre><code>$sideEffect = Set::strings('hello', 'world')-&gt;foreach(\n    function(string $string): void {\n        echo $string.' ';\n    },\n);\n</code></pre>"},{"location":"structures/set/#-groupby","title":"<code>-&gt;groupBy()</code>","text":"<p>This will create multiples sets with elements regrouped under the same key computed by the given function.</p> <pre><code>$urls = Set::strings(\n    'http://example.com',\n    'http://example.com/foo',\n    'https://example.com',\n    'ftp://example.com',\n);\n/** @var Innmind\\Immutable\\Map&lt;string, Set&lt;string&gt;&gt; */\n$map = $urls-&gt;groupBy(fn(string $url): string =&gt; \\parse_url($url)['scheme']);\n$map\n    -&gt;get('http')\n    -&gt;match(\n        static fn($group) =&gt; $group,\n        static fn() =&gt; Set::strings(),\n    )\n    -&gt;equals(Set::strings('http://example.com', 'http://example.com/foo')); // true\n$map\n    -&gt;get('https')\n    -&gt;match(\n        static fn($group) =&gt; $group,\n        static fn() =&gt; Set::strings(),\n    )\n    -&gt;equals(Set::strings('https://example.com')); // true\n$map\n    -&gt;get('ftp')\n    -&gt;match(\n        static fn($group) =&gt; $group,\n        static fn() =&gt; Set::strings(),\n    )\n    -&gt;equals(Set::strings('ftp://example.com')); // true\n</code></pre>"},{"location":"structures/set/#-partition","title":"<code>-&gt;partition()</code>","text":"<p>This method is similar to <code>-&gt;groupBy()</code> method but the map keys are always booleans. The difference is that here the 2 keys are always present whereas with <code>-&gt;groupBy()</code> it will depend on the original set.</p> <pre><code>$set = Set::ints(1, 2, 3);\n/** @var Map&lt;bool, Set&lt;int&gt;&gt; */\n$map = $set-&gt;partition(fn($int) =&gt; $int % 2 === 0);\n$map\n    -&gt;get(true)\n    -&gt;match(\n        static fn($partition) =&gt; $partition,\n        static fn() =&gt; Set::ints(),\n    )\n    -&gt;equals(Set::ints(2)); // true\n$map\n    -&gt;get(false)\n    -&gt;match(\n        static fn($partition) =&gt; $partition,\n        static fn() =&gt; Set::ints(),\n    )\n    -&gt;equals(Set::ints(1, 3)); // true\n</code></pre>"},{"location":"structures/set/#-sort","title":"<code>-&gt;sort()</code>","text":"<p>It will transform the set into an ordered sequence.</p> <pre><code>$sequence = Set::ints(1, 4, 2, 3)-&gt;sort(fn($a, $b) =&gt; $a &lt;=&gt; $b);\n$sequence-&gt;equals(Sequence::ints(1, 2, 3, 4));\n</code></pre>"},{"location":"structures/set/#-unsorted","title":"<code>-&gt;unsorted()</code>","text":"<p>It will transform the set into an unordered sequence.</p> <pre><code>$sequence = Set::ints(1, 4, 2, 3)-&gt;unsorted();\n// is the same as\n$sequence = Sequence::of(...Set::of(1, 4, 2, 3)-&gt;toList());\n</code></pre>"},{"location":"structures/set/#-clear","title":"<code>-&gt;clear()</code>","text":"<p>Create an empty new set of the same type. (To avoid to redeclare the types manually in a docblock)</p> <pre><code>$set = Set::ints(1);\n$set-&gt;clear()-&gt;size(); // 0\n</code></pre>"},{"location":"structures/set/#-safeguard","title":"<code>-&gt;safeguard()</code>","text":"<p>This method allows you to make sure all values conforms to an assertion before continuing using the set.</p> <pre><code>$uniqueFiles = Set::of(\n    new \\ArrayObject(['name' =&gt; 'a']),\n    new \\ArrayObject(['name' =&gt; 'b']),\n    new \\ArrayObject(['name' =&gt; 'c']),\n    new \\ArrayObject(['name' =&gt; 'a']),\n)\n    -&gt;safeguard(\n        Set::strings()\n        static fn(Set $names, string $value) =&gt; match ($names-&gt;contains($value['name'])) {\n            true =&gt; throw new \\LogicException(\"{$value['name']} is already used\"),\n            false =&gt; $names-&gt;add($value['name']),\n        },\n    );\n</code></pre> <p>This example will throw because there is the value <code>a</code> twice.</p> <p>This method is especially useful for deferred or lazy sets because it allows to make sure all values conforms after this call whithout unwrapping the whole set first. The downside of this lazy evaluation is that some operations may start before reaching a non conforming value (example below).</p> <pre><code>Set::lazy(function() {\n    yield new \\ArrayObject(['name' =&gt; 'a']);\n    yield new \\ArrayObject(['name' =&gt; 'b']);\n    yield new \\ArrayObject(['name' =&gt; 'c']);\n    yield new \\ArrayObject(['name' =&gt; 'a']);\n})\n    -&gt;safeguard(\n        Set::strings()\n        static fn(Set $names, string $value) =&gt; match ($names-&gt;contains($value['name'])) {\n            true =&gt; throw new \\LogicException(\"{$value['name']} is already used\"),\n            false =&gt; $names-&gt;add($value['name']),\n        },\n    )\n    -&gt;foreach(static fn($value) =&gt; print($value['name']));\n</code></pre> <p>This example will print <code>a</code>, <code>b</code> and <code>c</code> before throwing an exception because of the second <code>a</code>. Use this method carefully.</p>"},{"location":"structures/set/#-memoize","title":"<code>-&gt;memoize()</code>","text":"<p>This method will load all the values in memory. This is useful only for a deferred or lazy <code>Set</code>, the other set will be unaffected.</p> <pre><code>$set = Set::lazy(function() {\n    $stream = \\fopen('some-file', 'r');\n    while (!\\feof($stream)) {\n        yield \\fgets($stream);\n    }\n})\n    -&gt;map(static fn($line) =&gt; \\strtoupper($line)) // still no line loaded here\n    -&gt;memoize(); // load all lines and apply strtoupper on each\n</code></pre>"},{"location":"structures/set/#-snap","title":"<code>-&gt;snap()</code>","text":"<p>This method indicates that the <code>Set</code> will be memoized when a method that needs to load the data is called.</p> <pre><code>$sequence = Set::lazy(function() {\n    $stream = \\fopen('some-file', 'r');\n    while (!\\feof($stream)) {\n        yield \\fgets($stream);\n    }\n})\n    -&gt;map(static fn($line) =&gt; \\trim($line, \"\\n\"))\n    -&gt;exclude(static fn($line) =&gt; $line === '')\n    -&gt;snap()\n    -&gt;map(static fn($line) =&gt; \\strtoupper($line)); // still no line loaded here\n</code></pre> <p>Unlike <code>-&gt;memoize()</code>, if no code after this needs to access the data then nothing is loaded but it some does then it will load all non empty lines at once.</p>"},{"location":"structures/state/","title":"<code>State</code>","text":"Deprecated <p><code>State</code> is deprecated and will be removed in the next major release.</p> <p>The <code>State</code> monad allows you to build a set of pure steps to compute a new state. Since the initial state is given when all the steps are built it means that all steps are lazy, this use function composition (so everything is kept in memory).</p> <p>The state and value can be of any type.</p>"},{"location":"structures/state/#of","title":"<code>::of()</code>","text":"<pre><code>use Innmind\\Immutable\\{\n    State,\n    State\\Result,\n};\n\n/** @var State&lt;array, int&gt; */\n$state = State::of(function(array $logs) {\n    return Result::of($logs, 0);\n});\n</code></pre>"},{"location":"structures/state/#-map","title":"<code>-&gt;map()</code>","text":"<p>This method will modify the value without affecting the currently held state.</p> <pre><code>use Innmind\\Immutable\\{\n    State,\n    State\\Result,\n};\n\n/** @var State&lt;array, int&gt; */\n$state = State::of(function(array $logs) {\n    return Result::of($logs, 0);\n});\n\n$state = $state-&gt;map(fn($value) =&gt; $value + 1);\n</code></pre>"},{"location":"structures/state/#-flatmap","title":"<code>-&gt;flatMap()</code>","text":"<p>This method allows you to modify both state and values.</p> <pre><code>use Innmind\\Immutable\\{\n    State,\n    State\\Result,\n};\n\n/** @var State&lt;array, int&gt; */\n$state = State::of(function(array $logs) {\n    return Result::of($logs, 0);\n});\n\n$state = $state-&gt;flatMap(fn($value) =&gt; State::of(function(array $logs) use ($value) {\n    $value++;\n\n    return Result::of(\n        \\array_merge($logs, \"The new value is $value\"),\n        $value,\n    );\n}));\n</code></pre>"},{"location":"structures/state/#-run","title":"<code>-&gt;run()</code>","text":"<p>This is the only place where you can run the steps to compute the new state.</p> <pre><code>use Innmind\\Immutable\\{\n    State,\n    State\\Result,\n};\n\n/** @var State&lt;array, int&gt; */\n$result = State::of(function(array $logs) {\n    return Result::of($logs, 0);\n})\n    -&gt;map(fn($value) =&gt; $value + 1)\n    -&gt;flatMap(fn($value) =&gt; State::of(function(array $logs) use ($value) {\n        $value++;\n\n        return Result::of(\n            \\array_merge($logs, \"The new value is $value\"),\n            $value,\n        );\n    }))\n    -&gt;run([]);\n\n$result-&gt;state(); // ['The new value is 2']\n$result-&gt;value(); // 2\n</code></pre>"},{"location":"structures/str/","title":"<code>Str</code>","text":"<p>This class gives a higher api to manipulate strings.</p>"},{"location":"structures/str/#of","title":"<code>::of()</code>","text":"<p>This named constructor will create a new object for the given string.</p> <pre><code>use Innmind\\Immutable\\Str;\n\n$str = Str::of('whatever');\n$str instanceof Str; // true\n</code></pre> <p>You can also specify the encoding to use for manupilating the string.</p> <pre><code>$str = Str::of('\ud83d\udc4b', Str\\Encoding::utf8);\n$str-&gt;length(); // 1\nStr::of('\ud83d\udc4b')-&gt;length(); // 4\n</code></pre> <p><code>Str\\Encoding::utf8</code> is the default value when not specified</p>"},{"location":"structures/str/#-tostring","title":"<code>-&gt;toString()</code>","text":"<p>This will return the encapsulated string.</p> <pre><code>Str::of('whataver')-&gt;toString(); // 'whatever'\n</code></pre>"},{"location":"structures/str/#-encoding","title":"<code>-&gt;encoding()</code>","text":"<p>This will return the encoding used to manipulate the string.</p> <pre><code>Str::of('', 'UTF-8')-&gt;encoding() === Str\\Encoding::utf8; // true\n</code></pre>"},{"location":"structures/str/#-toencoding","title":"<code>-&gt;toEncoding()</code>","text":"<p>Use this method to change the encoding used to manipulate the string.</p> <pre><code>Str::of('\ud83d\udc4b')-&gt;toEncoding(Str\\Encoding::utf8);\n</code></pre>"},{"location":"structures/str/#-split","title":"<code>-&gt;split()</code>","text":"<p>Use this method to split a string into a <code>Sequence</code> of smaller strings.</p> <pre><code>Str::of('foo')-&gt;split()-&gt;equals(Sequence::of(\n    Str::of('f'),\n    Str::of('o'),\n    Str::of('o'),\n));\nStr::of('foo|bar')-&gt;split('|')-&gt;equals(Sequence::of(\n    Str::of('foo'),\n    Str::of('bar'),\n));\n</code></pre>"},{"location":"structures/str/#-chunk","title":"<code>-&gt;chunk()</code>","text":"<p>This will create a <code>Sequence</code> of strings of the given size.</p> <pre><code>Str::of('foobar')-&gt;chunk(2)-&gt;equals(Sequence::of(\n    Str::class,\n    Str::of('fo'),\n    Str::of('ob'),\n    Str::of('ar'),\n));\n</code></pre>"},{"location":"structures/str/#-position","title":"<code>-&gt;position()</code>","text":"<p>Returns the position of the searched string in the original string.</p> <pre><code>Str::of('foobar')-&gt;position('ob'); // Maybe::just(2)\nStr::of('foobar')-&gt;position('unknown'); // Maybe::nothing()\n</code></pre>"},{"location":"structures/str/#-replace","title":"<code>-&gt;replace()</code>","text":"<p>Replace the searched string by its replacement.</p> <pre><code>Str::of('foobar')-&gt;replace('ob', 'bo')-&gt;equals(Str::of('foboar')); // true\n</code></pre>"},{"location":"structures/str/#-toupper","title":"<code>-&gt;toUpper()</code>","text":"<p>Return the string in upper case.</p> <pre><code>Str::of('foobar')-&gt;toUpper()-&gt;equals(Str::of('FOOBAR'));\n</code></pre>"},{"location":"structures/str/#-tolower","title":"<code>-&gt;toLower()</code>","text":"<p>Return the string in lower case.</p> <pre><code>Str::of('FOOBAR')-&gt;toUpper()-&gt;equals(Str::of('foobar'));\n</code></pre>"},{"location":"structures/str/#-length","title":"<code>-&gt;length()</code>","text":"<p>Returns the length of the string depending on the used encoding.</p> <pre><code>Str::of('\ud83d\udc4b', Str\\Encoding::utf8)-&gt;length(); // 1\nStr::of('\ud83d\udc4b')-&gt;length(); // 4\n</code></pre>"},{"location":"structures/str/#-empty","title":"<code>-&gt;empty()</code>","text":"<p>Check if the string is an empty string.</p> <pre><code>Str::of('')-&gt;empty(); // true\nStr::of('', Str\\Encoding::utf8)-&gt;empty(); // true\nStr::of('null')-&gt;empty(); // false\nStr::of('0')-&gt;empty(); // false\nStr::of('false')-&gt;empty(); // false\n</code></pre>"},{"location":"structures/str/#-reverse","title":"<code>-&gt;reverse()</code>","text":"<p>Reverse the order of the characters.</p> <pre><code>Str::of('foobar')-&gt;reverse()-&gt;equals(Str::of('raboof'));\n</code></pre>"},{"location":"structures/str/#-rightpad","title":"<code>-&gt;rightPad()</code>","text":"<p>Add the given string to the right of the string in order of the new string to be at least of the given size.</p> <pre><code>Str::of('Alien')-&gt;rightPad(10)-&gt;equals(Str::of('Alien     '));\nStr::of('Alien')-&gt;rightPad(10, '_')-&gt;equals(Str::of('Alien_____'));\nStr::of('Alien')-&gt;rightPad(3, '_')-&gt;equals(Str::of('Alien'));\n</code></pre>"},{"location":"structures/str/#-leftpad","title":"<code>-&gt;leftPad()</code>","text":"<p>Add the given string to the left of the string in order of the new string to be at least of the given size.</p> <pre><code>Str::of('Alien')-&gt;leftPad(10)-&gt;equals(Str::of('     Alien'));\nStr::of('Alien')-&gt;leftPad(10, '_')-&gt;equals(Str::of('_____Alien'));\nStr::of('Alien')-&gt;leftPad(3, '_')-&gt;equals(Str::of('Alien'));\n</code></pre>"},{"location":"structures/str/#-unipad","title":"<code>-&gt;uniPad()</code>","text":"<p>Add the given string to both sides of the string in order of the new string to be at least of the given size.</p> <pre><code>Str::of('Alien')-&gt;uniPad(10,)-&gt;equals(Str::of('  Alien   '));\nStr::of('Alien')-&gt;uniPad(10, '_')-&gt;equals(Str::of('__Alien___'));\n</code></pre>"},{"location":"structures/str/#-repeat","title":"<code>-&gt;repeat()</code>","text":"<p>Repeat the original string the number of given times.</p> <pre><code>Str::of('foo')-&gt;repeat(3)-&gt;equals(Str::of('foofoofoo'));\n</code></pre>"},{"location":"structures/str/#-stripslashes","title":"<code>-&gt;stripSlashes()</code>","text":"<p>Same behaviour as the native <code>stripslashes</code> function.</p>"},{"location":"structures/str/#-stripcslashes","title":"<code>-&gt;stripCSlashes()</code>","text":"<p>Same behaviour as the native <code>stripcslashes</code> function.</p>"},{"location":"structures/str/#-wordcount","title":"<code>-&gt;wordCount()</code>","text":"<p>Counts the number in the string.</p> <pre><code>Str::of('foo bar')-&gt;wordCount(); // 2\n</code></pre>"},{"location":"structures/str/#-words","title":"<code>-&gt;words()</code>","text":"<p>The list of words with their position.</p> <pre><code>Str::of('foo bar')-&gt;words()-&gt;equals(\n    Map::of(\n        [0, Str::of('foo')],\n        [4, Str::of('bar')],\n    ),\n);\n</code></pre>"},{"location":"structures/str/#-pregsplit","title":"<code>-&gt;pregSplit()</code>","text":"<p>Split the string using a regular expression.</p> <pre><code>Str::of('hypertext language, programming')-&gt;pregSplit('/[\\s,]+/')-&gt;equals(\n    Sequence::of(\n        Str::of('hypertext'),\n        Str::of('language'),\n        Str::of('programming'),\n    ),\n);\n</code></pre>"},{"location":"structures/str/#-matches","title":"<code>-&gt;matches()</code>","text":"<p>Check if the string match the given regular expression.</p> <pre><code>Str::of('abcdef')-&gt;matches('/^a/'); // true\nStr::of('abcdef')-&gt;matches('/^b/'); // false\n</code></pre>"},{"location":"structures/str/#-capture","title":"<code>-&gt;capture</code>","text":"<p>Return a map of the elements matching the regular expression.</p> <pre><code>Str::of('http://www.php.net/index.html')\n    -&gt;capture('@^(?:http://)?(?P&lt;host&gt;[^/]+)@i')\n    -&gt;equals(\n        Map::of(\n            [0, Str::of('http://www.php.net')],\n            [1, Str::of('www.php.net')],\n            ['host', Str::of('www.php.net')],\n        ),\n    );\n</code></pre>"},{"location":"structures/str/#-pregreplace","title":"<code>-&gt;pregReplace()</code>","text":"<p>Replace part of the string by using a regular expression.</p> <pre><code>Str::of('April 15, 2003')\n    -&gt;pregReplace('/(\\w+) (\\d+), (\\d+)/i', '${1}1,$3')\n    -&gt;equals(Str::of('April1,2003'));\n</code></pre>"},{"location":"structures/str/#-substring","title":"<code>-&gt;substring()</code>","text":"<p>Return part of the string.</p> <pre><code>Str::of('foobar')-&gt;substring(3)-&gt;equals(Str::of('bar')); // true\nStr::of('foobar')-&gt;substring(3, 1)-&gt;equals(Str::of('b')); // true\n</code></pre>"},{"location":"structures/str/#-take","title":"<code>-&gt;take()</code>","text":"<p>Return a new string with only the n first characters.</p> <pre><code>Str::of('foobar')-&gt;take(3)-&gt;equals(Str::of('foo')); // true\n</code></pre>"},{"location":"structures/str/#-takeend","title":"<code>-&gt;takeEnd()</code>","text":"<p>Return a new string with only the n last characters.</p> <pre><code>Str::of('foobar')-&gt;takeEnd(3)-&gt;equals(Str::of('bar')); // true\n</code></pre>"},{"location":"structures/str/#-drop","title":"<code>-&gt;drop()</code>","text":"<p>Return a new string without the n first characters.</p> <pre><code>Str::of('foobar')-&gt;drop(3)-&gt;equals(Str::of('bar')); // true\n</code></pre>"},{"location":"structures/str/#-dropend","title":"<code>-&gt;dropEnd()</code>","text":"<p>Return a new string without the n last characters.</p> <pre><code>Str::of('foobar')-&gt;dropEnd(3)-&gt;equals(Str::of('foo')); // true\n</code></pre>"},{"location":"structures/str/#-sprintf","title":"<code>-&gt;sprintf()</code>","text":"<p>Return a formatted string.</p> <pre><code>Str::of('%s %s')\n    -&gt;sprintf('hello', 'world')\n    -&gt;equals(Str::of('hello world')); // true\n</code></pre>"},{"location":"structures/str/#-ucfirst","title":"<code>-&gt;ucfirst()</code>","text":"<p>Return the string with the first letter as uppercase.</p> <pre><code>Str::of('foobar')-&gt;ucfirst()-&gt;equals(Str::of('Foobar'));\n</code></pre>"},{"location":"structures/str/#-camelize","title":"<code>-&gt;camelize()</code>","text":"<p>Return a CamelCase representation of the string.</p> <pre><code>Str::of('foo bar_baz')-&gt;camelize()-&gt;equals(Str::of('fooBarBaz'));\n</code></pre>"},{"location":"structures/str/#-append","title":"<code>-&gt;append()</code>","text":"<p>Append a string at the end of the current one.</p> <pre><code>Str::of('foo')-&gt;append('bar')-&gt;equals(Str::of('foobar')); // true\n</code></pre>"},{"location":"structures/str/#-prepend","title":"<code>-&gt;prepend()</code>","text":"<p>Prepend a string at the beginning of the current one.</p> <pre><code>Str::of('foo')-&gt;prepend('bar')-&gt;equals(Str::of('barfoo')); // true\n</code></pre>"},{"location":"structures/str/#-equals","title":"<code>-&gt;equals()</code>","text":"<p>Check if the 2 strings are equal.</p> <pre><code>Str::of('foo')-&gt;equals(Str::of('foo')); // true\nStr::of('foo')-&gt;equals(Str::of('foo', Str\\Encoding::utf8)); // true\nStr::of('foo')-&gt;equals(Str::of('bar')); // false\n</code></pre>"},{"location":"structures/str/#-trim","title":"<code>-&gt;trim()</code>","text":"<p>Remove whitespace characters from both ends of the string.</p> <pre><code>Str::of('  foo ')-&gt;trim()-&gt;equals(Str::of('foo')); // true\n</code></pre>"},{"location":"structures/str/#-contains","title":"<code>-&gt;contains()</code>","text":"<p>Check if the string contains another string.</p> <pre><code>Str::of('foobar')-&gt;contains('ob'); // true\nStr::of('foobar')-&gt;contains('baz'); // false\n</code></pre>"},{"location":"structures/str/#-startswith","title":"<code>-&gt;startsWith()</code>","text":"<p>Check if the current string starts with the given string.</p> <pre><code>Str::of('foobar')-&gt;startsWith('foo'); // true\nStr::of('foobar')-&gt;startsWith('bar'); // false\n</code></pre>"},{"location":"structures/str/#-endswith","title":"<code>-&gt;endsWith()</code>","text":"<p>Check if the current string ends with the given string.</p> <pre><code>Str::of('foobar')-&gt;endsWith('bar'); // true\nStr::of('foobar')-&gt;endsWith('foo'); // false\n</code></pre>"},{"location":"structures/str/#-join","title":"<code>-&gt;join()</code>","text":"<p>This method will create a new <code>Str</code> object with all the values from the set/sequence separated by the vlue of the original string.</p> <pre><code>Str::of('|')\n    -&gt;join(Sequence::of('foo', 'bar', 'baz'))\n    -&gt;equals(Str::of('foo|bar|baz')); // true\n</code></pre>"},{"location":"structures/str/#-map","title":"<code>-&gt;map()</code>","text":"<p>This function will create a new <code>Str</code> object with the value modified by the given function.</p> <pre><code>$str = Str::of('foo|bar|baz')-&gt;map(\n    fn(string $value, string $encoding): string =&gt; \\implode(\n        ',',\n        \\explode('|', $string),\n    ),\n);\n$str-&gt;equals(Str::of('foo,bar,baz')); // true\n</code></pre>"},{"location":"structures/str/#-flatmap","title":"<code>-&gt;flatMap()</code>","text":"<p>This is similar to <code>-&gt;map()</code> but instead of the function returning a value it must return a new <code>Str</code> object.</p> <pre><code>$str = Str::of('foo|bar|baz')-&gt;flatMap(\n    fn(string $value, string $encoding): Str =&gt; Str::of(',')-&gt;join(\n        Sequence::of(...\\explode('|', $string)),\n    ),\n);\n$str-&gt;equals(Str::of('foo,bar,baz')); // true\n</code></pre>"},{"location":"structures/str/#-maybe","title":"<code>-&gt;maybe()</code>","text":"<p>The is a shortcut method, the 2 examples below do the same thing.</p> <pre><code>Str::of('foobar')-&gt;maybe(\n    static fn($str) =&gt; $str-&gt;startsWith('foo'),\n); // Maybe&lt;Str&gt;\n\n// is the same as\n\nMaybe::of(Str::of('foobar'))-&gt;filter(\n    static fn($str) =&gt; $str-&gt;startsWith('foo'),\n); // Maybe&lt;Str&gt;\n</code></pre>"},{"location":"structures/validation/","title":"<code>Validation</code>","text":"<p>This structure is similar to <code>Either</code> except that the right side is called success and left fail. The difference is that <code>Validation</code> allows to accumulate failures.</p> <p>For the examples below we will use the given imaginary functions:</p> <pre><code>use Innmind\\Immutable\\Validation;\n\n/**\n * @return Validation&lt;Error, string&gt;\n */\nfunction isEmail(string $value): Validation {\n    if (\\filter_var($value, \\FILTER_VALIDATE_EMAIL)) {\n        return Validation::success($value);\n    }\n\n    return Validation::fail(new Error(\"$value is not an email\"));\n}\n\n/**\n * @return Validation&lt;Error, string&gt;\n */\nfunction isLocal(string $value): Validation {\n    if (\\str_ends_with($value, '.local')) {\n        return Validation::success($value);\n    }\n\n    return Validation::fail(new Error('Not a local email'));\n}\n</code></pre> <p><code>Error</code> is imaginary class.</p>"},{"location":"structures/validation/#fail","title":"<code>::fail()</code>","text":"<p>This builds a <code>Validation</code> instance with the given value in the fail side.</p> <pre><code>$validation = Validation::fail($anyValue);\n</code></pre>"},{"location":"structures/validation/#success","title":"<code>::success()</code>","text":"<p>This builds a <code>Validation</code> instance with the given value in the success side.</p> <pre><code>$validation = Validation::success($anyValue);\n</code></pre>"},{"location":"structures/validation/#-map","title":"<code>-&gt;map()</code>","text":"<p>This will apply the map transformation on the success value if there is one, otherwise it's only a type change.</p> <pre><code>/** @var Validation&lt;Error, string&gt; */\n$validation = isEmail('foo@example.com');\n/** @var Either&lt;Error, Email&gt; */\n$email = $validation-&gt;map(fn(string $email): Email =&gt; new Email($email));\n</code></pre>"},{"location":"structures/validation/#-flatmap","title":"<code>-&gt;flatMap()</code>","text":"<p>This is similar to <code>-&gt;map()</code> but instead of returning the new success value you return a new <code>Validation</code> object.</p> <pre><code>/** @var Validation&lt;Error, string&gt; */\n$validation = isEmail('foo@example.com');\n/** @var Validation&lt;Error, string&gt; */\n$localEmail = $either-&gt;flatMap(fn(string $email): Validation =&gt; isLocal($email));\n</code></pre>"},{"location":"structures/validation/#-guard","title":"<code>-&gt;guard()</code>","text":"<p>This behaves like <code>-&gt;flatMap()</code> except any failure contained in the validation returned by the callable won't be recovered when calling <code>-&gt;xotherwise()</code>.</p>"},{"location":"structures/validation/#-match","title":"<code>-&gt;match()</code>","text":"<p>This is the only way to extract the wrapped value.</p> <pre><code>/** @var Email */\n$localEmail = isEmail($serverRequest)\n    -&gt;flatMap(fn(string $email): Validation =&gt; isLocal($email))\n    -&gt;map(static fn(string $email) =&gt; new Email($email))\n    -&gt;match(\n        fn(Email $email) =&gt; $email,\n        fn(Sequence $failures) =&gt; throw new \\Exception(\n            \\implode(', ', $failure-&gt;toList()),\n        ),\n    );\n</code></pre>"},{"location":"structures/validation/#-otherwise","title":"<code>-&gt;otherwise()</code>","text":"<p>This is like <code>-&gt;flatMap()</code> but is called when the instance contains failures. The callable must return a new <code>Validation</code> object.</p> <pre><code>/** @var Validation&lt;Error, string&gt; */\n$email = isEmail('invalid value')\n    -&gt;otherwise(fn() =&gt; isEmail('foo@example.com'));\n</code></pre>"},{"location":"structures/validation/#-xotherwise","title":"<code>-&gt;xotherwise()</code>","text":"<p>This behaves like <code>-&gt;otherwise()</code> except when conjointly used with <code>-&gt;guard()</code>. Guarded failures can't be recovered.</p> <p>An example of this problem is an HTTP router with 2 validations. One tries to validate it's a <code>POST</code> request, then validates the request body, the other tries to validate a <code>GET</code> request. It would look something like this:</p> <pre><code>$result = validatePost($request)\n    -&gt;flatMap(static fn() =&gt; validateBody($request))\n    -&gt;otherwise(static fn() =&gt; validateGet($request));\n</code></pre> <p>The problem here is that if the request is indeed a <code>POST</code> we try to validate the body. But if the latter fails then we try to validate it's a <code>GET</code> query. In this case the failure would indicate the request is not a <code>GET</code>, which doesn't make sense.</p> <p>The correct approach is:</p> <pre><code>$result = validatePost($request)\n    -&gt;guard(static fn() =&gt; validateBody($request))\n    -&gt;xotherwise(static fn() =&gt; validateGet($request));\n</code></pre> <p>This way if the body validation fails it will return this failure and not that it's not a <code>GET</code>.</p>"},{"location":"structures/validation/#-mapfailures","title":"<code>-&gt;mapFailures()</code>","text":"<p>This is similar to the <code>-&gt;map()</code> function but will be applied on each failure.</p> <pre><code>/** @var Either&lt;Exception, string&gt; */\n$email = isEmail('foo@example.com')\n    -&gt;mapFailures(fn(Error $error) =&gt; new \\Exception($error-&gt;toString()));\n</code></pre>"},{"location":"structures/validation/#-and","title":"<code>-&gt;and()</code>","text":"<p>This method allows to aggregate the success values of 2 <code>Validation</code> objects or aggregates the failures if at least one of them is a failure.</p> <pre><code>$foo = isEmail('foo@example.com');\n$bar = isEmail('bar@example.com');\n$baz = isEmail('invalid value');\n$foobar = isEmail('another value');\n\n$foo\n    -&gt;and(\n        $bar,\n        static fn($a, $b) =&gt; [$a, $b],\n    )\n    -&gt;match(\n        static fn($value) =&gt; $value,\n        static fn() =&gt; null,\n    ); // returns ['foo@example.com', 'bar@example.com']\n$foo\n    -&gt;and(\n        $baz,\n        static fn($a, $b) =&gt; [$a, $b],\n    )\n    -&gt;match(\n        static fn() =&gt; null,\n        static fn($failures) =&gt; $failures-&gt;toList(),\n    ); // returns [new Error('invalid value is not an email')]\n$foobar\n    -&gt;and(\n        $baz,\n        static fn($a, $b) =&gt; [$a, $b],\n    )\n    -&gt;match(\n        static fn() =&gt; null,\n        static fn($failures) =&gt; $failures-&gt;toList(),\n    ); // returns [new Error('another value is not an email'), new Error('invalid value is not an email')]\n</code></pre>"},{"location":"structures/validation/#-maybe","title":"<code>-&gt;maybe()</code>","text":"<p>This returns a <code>Maybe</code> containing the success value, in case of failures it returns a <code>Maybe</code> with nothing inside.</p> <pre><code>Validation::success('something')-&gt;maybe()-&gt;match(\n    static fn($value) =&gt; $value,\n    static fn() =&gt; null,\n); // returns 'something'\nValidation::fail('something')-&gt;maybe()-&gt;match(\n    static fn($value) =&gt; $value,\n    static fn() =&gt; null,\n); // returns null\n</code></pre>"},{"location":"structures/validation/#-either","title":"<code>-&gt;either()</code>","text":"<p>This returns an <code>Either</code> containing the success value as the right side, in case of failures it returns an <code>Either</code> with failures as the left side.</p> <pre><code>Validation::success('something')-&gt;either()-&gt;match(\n    static fn($value) =&gt; $value,\n    static fn() =&gt; null,\n); // returns 'something'\nValidation::fail('something')-&gt;either()-&gt;match(\n    static fn() =&gt; null,\n    static fn($value) =&gt; $value,\n); // returns Sequence&lt;string&gt;\n</code></pre>"},{"location":"use-cases/","title":"Use cases","text":"<p>In this chapter you'll find a set of use cases using data structures already shown in previous chapters.</p>"},{"location":"use-cases/lazy-file/","title":"How to read a file","text":"<p>This example below will show you how to build complex pipelines to read files without ever loading the whole file in memory, allowing you to read any file's size.</p> <p>This example below looks for a user in a csv file with a score above <code>100</code>.</p> <pre><code>use Innmind\\Immutable\\{\n    Sequence,\n    Str,\n};\n\n$lines = Sequence::lazy(function(callable $registerCleanup) {\n    $handle = \\fopen('users.csv', 'r');\n    $registerCleanup(fn() =&gt; \\fclose($handle));\n\n    while (!\\feof($handle)) {\n        yield (string) \\fgets($handle);\n    }\n\n    \\fclose($handle);\n});\n/** @var Maybe&lt;User&gt; */\n$user = $lines\n    -&gt;map(fn(string $line) =&gt; Str::of($line))\n    -&gt;map(fn(Str $line) =&gt; $line-&gt;trim())\n    -&gt;filter(fn(Str $line) =&gt; !$line-&gt;empty())\n    -&gt;filter(fn(Str $line) =&gt; $line-&gt;contains(','))\n    -&gt;map(fn(Str $line) =&gt; $line-&gt;split(','))\n    -&gt;map(fn(Sequence $columns) =&gt; User::of($columns)) // ficticious class\n    -&gt;find(fn(User $user) =&gt; $user-&gt;score() &gt; 100);\n</code></pre> <p>The final <code>$user</code> variable is an instance of <code>Maybe</code> because the user may or may not exist.</p> <p>If a user is found before the end of the file the sequence will stop reading the file and call the function passed to <code>$registerCleanup</code> allowing you to close the file handle properly.</p> <p>Since this is a lazy sequence the file is iterated over only when trying to extract a concrete value, in this case via <code>-&gt;find()</code>. This means that even though the pipeline contains multiple steps the file is read only once. This decoupling between reading the file and building a pipeline to compute a value allows you to split the construction of the pipeline across multiple layers in your application without worrying about performance.</p> <p>The other advantage of this technique is that it allows to read files that may not fit in memory.</p>"},{"location":"use-cases/lazy-file/#merging-multiple-files-in-a-single-pipeline","title":"Merging multiple files in a single pipeline","text":"<p>The lazyness described above still works when you combine multiple lazy sequences.</p> <pre><code>$openFile = fn(string $name) =&gt; function(callable $registerCleanup) use ($name) {\n    $handle = \\fopen($name, 'r');\n    $registerCleanup(fn() =&gt; \\fclose($handle));\n\n    while (!\\feof($handle)) {\n        yield (string) \\fgets($handle);\n    }\n\n    \\fclose($handle);\n};\n\n$users = Sequence::lazy($openFile('users1.csv'))\n    -&gt;append(Sequence::lazy($openFile('users2.csv')))\n    -&gt;append(Sequence::lazy($openFile('users3.csv')));\n\n/** @var callable(Sequence&lt;string&gt;): Maybe&lt;User&gt; $findUser */\n$findUser = function(Sequence $users): Maybe {\n    // todo build a pipeline to find a user\n};\n\n$user = $findUser($users);\n</code></pre> <p>Here we create a sequence that will sequentially read the 3 files <code>users1.csv</code>, <code>users2.csv</code> and <code>users3.csv</code> but the <code>$findUser</code> function is not aware of where the data comes from. This composition will open <code>users2.csv</code> only if the user is not found in <code>users1.csv</code>.</p> <p>In this example the 3 sources are all files but you could mix the sources with different generators, for example you could combine from a file with another one coming from a database.</p>"},{"location":"use-cases/parsing/","title":"Parsing strings","text":"<p>This example will show how to parse a string without relying on exceptions to handle errors.</p> <p>This is a simple case to parse the simplest form of a media type (ie <code>topLevel/subType</code>)</p> <pre><code>use Innmind\\Immutable\\{\n    Str,\n    Maybe,\n};\n\nfinal class MediaType\n{\n    /**\n     * @return Maybe&lt;self&gt;\n     */\n    public static function of(string $topLevel, string $subType): Maybe\n    {\n        if (/* $topLevel is not a valid one */) {\n            /** @var Maybe&lt;self&gt; */\n            return Maybe::nothing();\n        }\n\n        return Maybe::just(new self($topLevel, $subType));\n    }\n}\n\n/** @var callable(string): Maybe&lt;MediaType&gt; $parse */\n$parse = function(string $string): Maybe {\n    // the regex only validate the form, it doesn't check the top level is a correct one\n    $components = Str::of($string)-&gt;capture('~(?&lt;topLevel&gt;[a-z]+)/(?&lt;subType&gt;[a-z\\-]+)~');\n\n    return Maybe::all($components-&gt;get('topLevel'), $components-&gt;get('subType'))\n        -&gt;flatMap(fn(Str $topLevel, Str $subType) =&gt; MediaType::of(\n            $topLevel-&gt;toString(),\n            $subType-&gt;toString(),\n        ));\n}\n\n$parse('application/json'); // Maybe::just(new MediaType('application', 'json'))\n$parse(''); // Maybe::nothing() because no top level nor sub type\n$parse('application/'); // Maybe::nothing() because no sub type\n$parse('/json'); // Maybe::nothing() because no top level\n$parse('unknown/json'); // Maybe::nothing() because top level is not valid\n</code></pre>"}]}